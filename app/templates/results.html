<!DOCTYPE html>
{% extends "layout.html" %}

{% block body %}

<!-- responsive web design tag to adjust for all devices -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" />

<style>
	.hide {
		display: none
	}
</style>

<script type=text/javascript charset="utf-8">
	document.getElementById("menu").style="top:0px; text-align:right; height:6%; margin-top: -10px; margin-left: 20vw;";
//	document.getElementsByClassName("text_link")[0].style="margin-right: 21vw;";
//	document.getElementsByClassName("top-container")[0].style.marginRight="20vw";
	document.getElementById("main_heading").style="magin:10px; text-align:left; ";
	// document.getElementById("pattieword").style.paddingLeft = "3vw";
	// Make the pattiword in the top center fixed position
	document.getElementById("pattieword").style="position: fixed; top: 0px; left: 50%; transform: translate(-50%, 0%); color: #4c6d92";
	// document.getElementById("copyright").style= "position: fixed; top:12%; left: 16%; width: 10vw";
	// Make the copyright in the bottom right with symbol even if it overlaps
	document.getElementById("copyright").style= "position: fixed; bottom: 0px; right: 0px; width: 10vw;opacity:0;";
	document.getElementsByClassName("page")[0].style="height:90%";
	//console.log(document.getElementsByClassName("page")[0].style);
	document.getElementById("home_link").style.display="inline-block";


//changing the heading for each page
document.getElementById("heading1").style= "position:fixed; top:-1%; left:0%";
//console.log('{{dataset}}');
//document.getElementById("tutorial").innerHTML= "<a href='{{url_for('static', filename='about.html')}}' class='text_link' onclick=\"return !window.open(this.href, 'tutorial', 'width=800,height=600')\" target=\"_blank\" style='text-align:left; margin-left:-1175px'>About</a>\
	//                                              <dt><a href=# class='text_link' style='text-align:left; margin-left:-1070px' onclick='tutorial()'>A Step-by-Step Intro </a>";

const pattie_blue = '#62b2ff'
const color_code_table = {
	0: 'white',
	1: pattie_blue
}
var path = {{path|tojson}};
var num_cls = {{num_cls|tojson}};
var dataset = {{dataset|tojson}}
const query_string = window.location.search;
const url_params = new URLSearchParams(query_string);
const dataset_opt = 'rss_feed';
// const dataset_opt = url_params.get('dataset_opt');
const entity = url_params.get('entity');
if (dataset_opt != 'PubMedAPI' && dataset_opt != 'Experts'){
	const entities_menu = document.getElementById('entities_menu');
	if (entities_menu) {
		entities_menu.style.opacity = 0;
	}
}
// else if (dataset_opt == 'DigiSquare'){

//   const entities_menu = document.getElementById('entities_menu');
// 	if (entities_menu) {
// 		entities_menu.style.opacity = 0;
// 	}
// }
// else if (dataset_opt == 'rss_feed'){
// 	const entities_menu = document.getElementById('entities_menu');
// 	if (entities_menu) {
// 		entities_menu.style.opacity = 0;
// 	}
// }
var zoom_in_threshold = 10;
if (dataset_opt == 'Experts') {
	zoom_in_threshold = 6;
}
var opened_id;
var opened_edges_id = new Set();
var doc_open = false;

//global functions
//click on tutorials
function tutorial(){
	introJs().start();
}



//show uploaded articles in a new window
function show_uploaded_articles(article,link_id){
	//var myWindow = window.close()
	var myWindow = window.open('', 'TextWindow', 'width=1000,height=700');
	//var myWindow = window.open('', '_self');
	myWindow.document.body.innerHTML='';
	//console.log(myWindow.document.body.innerHTML)
	var article_to_show=article;
 //console.log(article_to_show);
	article_to_show=article_to_show.replace(/_startinganewline_/g, '<br>');
	article_to_show=article_to_show.replace(/_singlequote_/g, "'");
	article_to_show=article_to_show.replace(/_doublequote_/g, '"');
 //console.log(article_to_show);
	myWindow.document.write('<p>'+article_to_show+'</p>');
 //console.log("color is " + document.getElementById(link_id).style.color)
	document.getElementById(link_id).style.color = "#551A8B";

}

//go home
function goHome(){
	window.history.back();
}


function getCurrentEntity() {
	let currentEntity = sessionStorage.getItem('currentEntity');
	return currentEntity;
}

function updateCurrentEntity(newEntity) {
	sessionStorage.setItem('currentEntity', newEntity);
}

function turnOnLoadingPrompt() {
	document.getElementById("cluster").style.opacity = 0.2;
	document.getElementById("query-secondary").style.opacity = 0.2;
	document.getElementById("Explore").style.opacity = 0.2;
	document.getElementsByTagName("nav")[0].style.opacity = 0.2;
	document.getElementById("loading").style.display="block";
}

function turnOffLoadingPrompt() {
	document.getElementById("cluster").style.opacity = 1.0;
	document.getElementById("query-secondary").style.opacity = 1.0;
	document.getElementById("Explore").style.opacity = 0.7;
	document.getElementsByTagName("nav")[0].style.opacity = 0.7;
	document.getElementById("loading").style.display="none";
}

function refreshEntity(entity){
	var needLoadingPrompt = false;
	/* trigger update only when selecting a radio button different from the current one */
	if (getCurrentEntity() !== entity) {
		$('#usrform').on('submit', function (e) {
		    e.preventDefault();
		    var dataset_opt = {{ dataset|tojson }}
			var num_cls = {{num_cls|tojson}}
			if (dataset_opt == 'Experts') {
		    window.location.assign({{url_for('cluster')|tojson}}
				+ '?dataset_opt=' + dataset_opt
				+ '&query=' + $('#query-secondary').val()
				+ '&entity=' + entity)
			} else {
		    window.location.assign({{url_for('cluster')|tojson}}
				+ '?dataset_opt=' + dataset_opt
				+ '&query=' + $('#query-secondary').val()
				+ '&entity=' + entity
				+ '&num_cls=' + num_cls)
			}
		});
	    	let dataset_opt = {{ dataset|tojson }}
			let num_cls = {{num_cls|tojson}}
			needLoadingPrompt = true;
			$('#usrform').submit();

		if(entity === "genes"){
			alert('Gene Entities feature is still in testing phases, please provide feedback if you encounter any issues');
		}
		if (needLoadingPrompt) {
			turnOnLoadingPrompt();
		}
	}

}



//open the panel for documents when click on the tab/bubble
function openDoc(evt, docName, keywordsName, id) {
	// Declare all variables
	var i, tabcontent, tablinks, keywords;
	// Get all elements with class="keywords" and hide them
	keywords = document.getElementsByClassName("keywords");
	for (i = 0; i < keywords.length; i++) {
		keywords[i].style.display = "none";

	}

	// Get all elements with class="tabcontent" and hide them
	tabcontent = document.getElementsByClassName("tabcontent");
	for (i = 0; i < tabcontent.length; i++) {
		tabcontent[i].style.display = "none";
	}

	// Get all elements with class="tablinks" and remove the class "active"
	tablinks = document.getElementsByClassName("tablinks");
	for (i = 0; i < tablinks.length; i++) {
	 //console.log(i)
		tablinks[i].className = tablinks[i].className.replace(" active", "");
	}

	// Show the current tab, and add an "active" class to the button that opened the tab
	document.getElementById(keywordsName).style.display = "block";
	document.getElementById(docName).style.display = "block";
	evt.currentTarget.className += " active";

 //console.log("circle is "+ id);
	d3.selectAll('circle').each(function(d){
		if (d.id == id){
		this.style = "stroke:gray"
	}else{
		this.style.stroke = "none";
	}

	});
	//else if (this.style.filter == "url(\"#f1\")"){
		//this.style.filter = "none"}
	//


	//console.log(d3.select("circle#" + id));
};

//open the linked page in a floating window
$("a.new_link").on("click", function() {
	var new_link = $(this).prop('href');
 //console.log(new_link);
	window.open(new_link, "_blank", "toolbar=yes,scrollbars=yes,resizable=yes,top=500,left=500,width=400,height=400");
});

function harmonic_mean (a, b ) {
		return (2 * a * b / (a+b) ) ;
};

//modify data
function modify_data (data, width, height, resize_factor) {

	var modified_data = [];
	var num_item = data.length ;
	var num_documents = 0 ;
	console.log(data);
	for (var i = 0; i < num_item; i++) {
		num_documents += data[i].count;
	}

	for (var i = 0; i < num_item; i++) {

		var short_keywords = shorten(data[i].keywords, data[i].count);
		var num_short_item = short_keywords.length;
		const cluster_radius = data[i].actual_radius * resize_factor;
		const font_scale = compute_font_scale(cluster_radius, short_keywords.map(k => k.term));

		for (var j = 0; j < num_short_item; j++) {
			temp_item = {} ;
			temp_item.id = i;
			temp_item.font_scale = font_scale;
            temp_item.keyword = short_keywords[j];
			temp_item.x = data[i].optimized_cx
			temp_item.y = data[i].optimized_cy + (-0.5* (num_short_item - 1) + j ) * font_scale * 3.2 + 0.5;
			temp_item.optimized_cx = data[i].optimized_cx;
			temp_item.optimized_cy = data[i].optimized_cy;
			temp_item.actual_radius = data[i].actual_radius;
			temp_item.min_resize_factor = resize_factor;
			modified_data.push(temp_item);
		}
	}
	return [modified_data, num_documents];
};

function shorten(words, count)  {
    var keywords = [];
    for (var i = 0 ; i < words.length ; i++) {
        var word = words[i];
        keywords.push({'term': word, 'flag': undefined, 'color_code': i % 2});
    }
    return keywords;
}

function compute_font_scale(cluster_radius, keywords) {
    const longest_term = [...keywords].sort((a, b) => b.length - a.length)[0];
    const text_block_width_factor = longest_term.length;
    const text_block_height_factor = keywords.length; // Adjust this based on line height
    const diagonal_length = Math.sqrt(text_block_width_factor * text_block_width_factor + text_block_height_factor * text_block_height_factor);
    const font_scale = cluster_radius / diagonal_length; // Adjusting the scaling factor for better fit
    return font_scale;
}

//  initialize timestamps for click data
var dateTime = new Date();
var search = {{query|tojson}};

function choose_bubbles(d){

	var cluster_id = d.id;
	var cluster_color_ = d3.select(this).style('fill');
	var cluster_color = cluster_color_.substring(3, cluster_color_.indexOf(')'));
	cluster_color = "rgba" + cluster_color + ', 0.30)'
    const url_user_modeling = {{url_for('user_modeling')|tojson}};

	if (this.style.filter != "url(\"#grayscale\")") { //deselect the circle
		current_selection_trace.removeId(cluster_id);

		this.style.filter = "url(\"#grayscale\")";
		this.style.stroke = "none"
		//console.log('cluster unclicked is ' + cluster_id)
		var unclicked = {'search':search, 'month':dateTime.getMonth(), 'day':dateTime.getDate(), 'year':dateTime.getFullYear(), 'hour':dateTime.getHours(), 'type':'unclicked', 'keywords':d['keywords']};

		// stream data back to server
		$.ajax({
				type: "POST",
				contentType: "application/json;charset=utf-8",
				url: url_user_modeling,
				traditional: "true",
				data: JSON.stringify(unclicked),
				dataType: "json"
			});

	} else {
		current_selection_trace.addId(cluster_id);

		this.style.filter = "none";
		this.style.stroke = "grey";
		//console.log('cluster clicked is ' + cluster_id)
		var clicked = {'search':search, 'month':dateTime.getMonth(), 'day':dateTime.getDate(), 'year':dateTime.getFullYear(), 'hour':dateTime.getHours(), 'type':'clicked', 'keywords':d['keywords']};

		// stream data back to server
		$.ajax({
				type: "POST",
				contentType: "application/json;charset=utf-8",
				url: url_user_modeling,
				traditional: "true",
				data: JSON.stringify(clicked),
				dataType: "json"
			});
	}


	var checkBox = $(`input[name="ids"][value="${d.id}"]`);
	checkBox.prop("checked", !checkBox.prop("checked"));
}

 var active_id
 //var active_id_prev

 var tooltip = d3.select("body")
 .append("div")
	.style("background-color", "grey")
	.style("border-radius", "5px")
	.style("padding", "10px")
	.style("width","300px")
	.style("color", "white")
	.style("position", "absolute")
	.style("z-index", "10")
	.style("visibility", "hidden");

function VoiceEdges(cluster) {
		var width = 1.0*document.getElementById("cluster").offsetWidth;
		var height = document.getElementById("cluster").offsetHeight;
		var edges = {{edges|safe}};
			for (pair in edges) {
				if (edges[pair]["clusterID"] == cluster) {
					if (edges[pair]["distance"] == "Very Similar") {
						//console.log("ver")
						//draw lines for the links
						var line = d3.select("svg")
							.append("line")
							.attr("id", cluster)
							.attr("stroke", "grey")
							.attr("stroke-width", 8)
							.attr("opacity", 0.25)
							.attr("x1", (200 + edges[pair].source[0] * 0.75 *(width-200)))
							.attr("y1", (150 + edges[pair].source[1] * 0.75 *(height-200)))
							.attr("x2", (200 + edges[pair].source[0] * 0.75 *(width-200)))
							.attr("y2", (150 + edges[pair].source[1] * 0.75 *(height-200)))
							.on("mouseover",function(){
								d3.selectAll("#edgeLabel"+$(cluster).attr("id")+"-"+cluster).transition().attr("opacity",0.75);
								document.getElementById("heuristicTable").style.visibility= "visible";
							})
							.on("mouseout",function(){
								d3.selectAll("#edgeLabel"+$(cluster).attr("id")+"-"+cluster).transition().attr("opacity",0)
								document.getElementById("heuristicTable").style.visibility= "hidden";
							})
							.transition()
							.duration(500)
							.attr("x2", (200 + edges[pair].target[0] * 0.75 *(width-200)))
							.attr("y2", (150 + edges[pair].target[1] * 0.75 *(height-200)));

						// get equidistant point to place text on edge
						var midX = (200 + edges[pair].source[0] * 0.75 *(width-200)) + ((200 + edges[pair].target[0] * 0.75 *(width-200)) - (200 + edges[pair].source[0] * 0.75 *(width-200))) * 0.50;
						var midY= (150 + edges[pair].source[1] * 0.75 *(height-200)) + ((150 + edges[pair].target[1] * 0.75 *(height-200)) - (150 + edges[pair].source[1] * 0.75 *(height-200))) * 0.50;

						var edgeLabel = d3.select("svg")
							.append("text")
							.attr("id","edgeLabel"+cluster)
							.attr('text-anchor', 'middle')
							.attr("x", midX)
							.attr("y", midY)
							.attr("opacity", 0)//.transition().duration(250).attr("opacity", 0.75)
							.attr("fill", "#4c6d92")
							.attr("font-size", 14)
							.text(edges[pair].distance)
							.on("mouseover",function(){
								d3.selectAll("#"+cluster).transition().attr("opacity",0.75);
								document.getElementById("heuristicTable").style.visibility= "visible";
							})
							.on("mouseout",function(){
								d3.selectAll("#"+cluster).transition().attr("opacity",0);
								document.getElementById("heuristicTable").style.visibility= "hidden";
							});
					}
					if (edges[pair]["distance"] == "Similar") {
						//console.log("sim")
						//draw lines for the links
						var line = d3.select("svg")
							.append("line")
							.attr("id", cluster)
							.attr("stroke", "grey")
							.attr("stroke-width", 2)
							.attr("opacity", 0.15)
							.attr("x1", (200 + edges[pair].source[0] * 0.75 *(width-200)))
							.attr("y1", (150 + edges[pair].source[1] * 0.75 *(height-200)))
							.attr("x2", (200 + edges[pair].source[0] * 0.75 *(width-200)))
							.attr("y2", (150 + edges[pair].source[1] * 0.75 *(height-200)))
							.on("mouseover",function(){
								d3.selectAll("#edgeLabel"+$(cluster).attr("id")+"-"+cluster).transition().attr("opacity",0.75);
								document.getElementById("heuristicTable").style.visibility= "visible";
							})
							.on("mouseout",function(){
								d3.selectAll("#edgeLabel"+$(cluster).attr("id")+"-"+cluster).transition().attr("opacity",0)
								document.getElementById("heuristicTable").style.visibility= "hidden";
							})
							.transition()
							.duration(500)
							.attr("x2", (200 + edges[pair].target[0] * 0.75 *(width-200)))
							.attr("y2", (150 + edges[pair].target[1] * 0.75 *(height-200)));

						// get equidistant point to place text on edge
						var midX = (200 + edges[pair].source[0] * 0.75 *(width-200)) + ((200 + edges[pair].target[0] * 0.75 *(width-200)) - (200 + edges[pair].source[0] * 0.75 *(width-200))) * 0.50;
						var midY= (150 + edges[pair].source[1] * 0.75 *(height-200)) + ((150 + edges[pair].target[1] * 0.75 *(height-200)) - (150 + edges[pair].source[1] * 0.75 *(height-200))) * 0.50;

						var edgeLabel = d3.select("svg")
							.append("text")
							.attr("id","edgeLabel"+cluster)
							.attr('text-anchor', 'middle')
							.attr("x", midX)
							.attr("y", midY)
							.attr("opacity", 0)//.transition().duration(250).attr("opacity", 0.75)
							.attr("fill", "#4c6d92")
							.attr("font-size", 12)
							.text(edges[pair].distance)
							.on("mouseover",function(){
								d3.selectAll("#"+cluster).transition().attr("opacity",0.75);
								document.getElementById("heuristicTable").style.visibility= "visible";
							})
							.on("mouseout",function(){
								d3.selectAll("#"+cluster).transition().attr("opacity",0);
								document.getElementById("heuristicTable").style.visibility= "hidden";
							});
					}

					if (edges[pair]["distance"] == "Distant") {
						//console.log("dis")
						//draw lines for the links
						var line = d3.select("svg")
							.append("line")
							.attr("id", cluster)
							.attr("stroke", "grey")
							.attr("stroke-width", 2)
							.attr("stroke-dasharray", "10,10")
							.attr("opacity", 0.10)
							.attr("x1", (200 + edges[pair].source[0] * 0.75 *(width-200)))
							.attr("y1", (150 + edges[pair].source[1] * 0.75 *(height-200)))
							.attr("x2", (200 + edges[pair].source[0] * 0.75 *(width-200)))
							.attr("y2", (150 + edges[pair].source[1] * 0.75 *(height-200)))
							.on("mouseover",function(){
								d3.selectAll("#edgeLabel"+$(cluster).attr("id")+"-"+cluster).transition().attr("opacity",0.75);
								document.getElementById("heuristicTable").style.visibility= "visible";
							})
							.on("mouseout",function(){
								d3.selectAll("#edgeLabel"+$(cluster).attr("id")+"-"+cluster).transition().attr("opacity",0);
								document.getElementById("heuristicTable").style.visibility= "hidden";
							})
							.transition()
							.duration(500)
							.attr("x2", (200 + edges[pair].target[0] * 0.75 *(width-200)))
							.attr("y2", (150 + edges[pair].target[1] * 0.75 *(height-200)));

						// get equidistant point to place text on edge
						var midX = (200 + edges[pair].source[0] * 0.75 *(width-200)) + ((200 + edges[pair].target[0] * 0.75 *(width-200)) - (200 + edges[pair].source[0] * 0.75 *(width-200))) * 0.50;
						var midY= (150 + edges[pair].source[1] * 0.75 *(height-200)) + ((150 + edges[pair].target[1] * 0.75 *(height-200)) - (150 + edges[pair].source[1] * 0.75 *(height-200))) * 0.50;

						var edgeLabel = d3.select("svg")
							.append("text")
							.attr("id","edgeLabel"+cluster)
							.attr('text-anchor', 'middle')
							.attr("x", midX)
							.attr("y", midY)
							.attr("opacity", 0)//.transition().duration(250).attr("opacity", 0.75)
							.attr("fill", "#4c6d92")
							.attr("font-size", 10)
							.text(edges[pair].distance)
							.on("mouseover",function(){
								d3.selectAll("#"+cluster).transition().attr("opacity",0.75);
								document.getElementById("heuristicTable").style.visibility= "visible";
							})
							.on("mouseout",function(){
								d3.selectAll("#"+cluster).transition().attr("opacity",0);
								document.getElementById("heuristicTable").style.visibility= "hidden";
							});
					}
				}
			}
		}

	function VoiceEdgesRemove(d) {
		// remove network edges
		d3.selectAll("line").remove()
		d3.selectAll("#edgeLabel").remove()
	}

	function showEdges(d){ //with edges
			//console.log("current id is " + d.id)
			//console.log(d)
			var width = 1.0*document.getElementById("cluster").offsetWidth;
			var height = document.getElementById("cluster").offsetHeight;
			//var id = d.id;
			//console.log(id);
			var edges = d.edges;
		 //console.log(d)

			//check if the lines have been drawn for the current cluster
			var overlappingLines = 0;
			d3.selectAll("line").each(function(){
				//console.log(this)
				//console.log($(this).attr("class"))
				if ($(this).attr("class") == d.id){
					overlappingLines += 1;
				}
			})
		 //console.log("edges are: " + edges)
			var lineId = 0;

				for (pair in edges) {
					//console.log(overlappingLines);

					if (edges[pair]["clusterID"] == d.id && overlappingLines == 0) {
						if (edges[pair]["distance"] == "Very Similar") {
						 //console.log("ver")
							//draw lines for the links
							var line = d3.select("svg")
								.append("line")
								.attr("class", d.id)
								.attr("id", lineId)
								.attr("stroke", "grey")
								.attr("stroke-width", 8)
								.attr("opacity", 0.25)
								.attr("x1", edges[pair].optimized_source[0])
								.attr("y1", edges[pair].optimized_source[1])
								.attr("x2", edges[pair].optimized_source[0])
								.attr("y2", edges[pair].optimized_source[1])
								.on("mouseover",function(){
									d3.selectAll("#edgeLabel"+$(this).attr("class")+"-"+this.id).transition().attr("opacity",0.75);
									document.getElementById("heuristicTable").style.visibility= "visible";
								})
								.on("mouseout",function(){
									d3.selectAll("#edgeLabel"+$(this).attr("class")+"-"+this.id).transition().attr("opacity",0)
									document.getElementById("heuristicTable").style.visibility= "hidden";
								})
								.transition()
								.duration(500)
								.attr("x2", edges[pair].optimized_target[0])
								.attr("y2", edges[pair].optimized_target[1]);

							// get equidistant point to place text on edge
							var midX = (200 + edges[pair].source[0] * 0.75 *(width-200)) + ((200 + edges[pair].target[0] * 0.75 *(width-200)) - (200 + edges[pair].source[0] * 0.75 *(width-200))) * 0.50;
							var midY= (150 + edges[pair].source[1] * 0.75 *(height-200)) + ((150 + edges[pair].target[1] * 0.75 *(height-200)) - (150 + edges[pair].source[1] * 0.75 *(height-200))) * 0.50;

							var edgeLabel = d3.select("svg")
								.append("text")
								.attr("class", "edgeLabel"+d.id)
								.attr("id","edgeLabel"+d.id+"-"+lineId)
								.attr('text-anchor', 'middle')
								.attr("x", midX)
								.attr("y", midY)
								.attr("opacity", 0)//.transition().duration(250).attr("opacity", 0.75)
								.attr("fill", "#4c6d92")
								.attr("font-size", 14)
								.text(edges[pair].distance)
								.on("mouseover",function(){
									d3.selectAll("#"+this.id).transition().attr("opacity",0.75);
									document.getElementById("heuristicTable").style.visibility= "visible";
								})
								.on("mouseout",function(){
									d3.selectAll("#"+this.id).transition().attr("opacity",0);
									document.getElementById("heuristicTable").style.visibility= "hidden";
								});
						}
						if (edges[pair]["distance"] == "Similar") {
						 //console.log("sim")
							//draw lines for the links
							var line = d3.select("svg")
								.append("line")
								.attr("class", d.id)
								.attr("id", lineId)
								.attr("stroke", "grey")
								.attr("stroke-width", 2)
								.attr("opacity", 0.15)
								.attr("x1", edges[pair].optimized_source[0])
								.attr("y1", edges[pair].optimized_source[1])
								.attr("x2", edges[pair].optimized_source[0])
								.attr("y2", edges[pair].optimized_source[1])
								.on("mouseover",function(){
									d3.selectAll("#edgeLabel"+$(this).attr("class")+"-"+this.id).transition().attr("opacity",0.75);
									document.getElementById("heuristicTable").style.visibility= "visible";
								})
								.on("mouseout",function(){
									d3.selectAll("#edgeLabel"+$(this).attr("class")+"-"+this.id).transition().attr("opacity",0)
									document.getElementById("heuristicTable").style.visibility= "hidden";
								})
								.transition()
								.duration(500)
								.attr("x2", edges[pair].optimized_target[0])
								.attr("y2", edges[pair].optimized_target[1]);

							// get equidistant point to place text on edge
							var midX = (200 + edges[pair].source[0] * 0.75 *(width-200)) + ((200 + edges[pair].target[0] * 0.75 *(width-200)) - (200 + edges[pair].source[0] * 0.75 *(width-200))) * 0.50;
							var midY= (150 + edges[pair].source[1] * 0.75 *(height-200)) + ((150 + edges[pair].target[1] * 0.75 *(height-200)) - (150 + edges[pair].source[1] * 0.75 *(height-200))) * 0.50;

							var edgeLabel = d3.select("svg")
								.append("text")
								.attr("class", "edgeLabel"+d.id)
								.attr("id","edgeLabel"+d.id+"-"+lineId)
								.attr('text-anchor', 'middle')
								.attr("x", midX)
								.attr("y", midY)
								.attr("opacity", 0)//.transition().duration(250).attr("opacity", 0.75)
								.attr("fill", "#4c6d92")
								.attr("font-size", 12)
								.text(edges[pair].distance)
								.on("mouseover",function(){
									d3.selectAll("#"+this.id).transition().attr("opacity",0.75);
									document.getElementById("heuristicTable").style.visibility= "visible";
								})
								.on("mouseout",function(){
									d3.selectAll("#"+this.id).transition().attr("opacity",0);
									document.getElementById("heuristicTable").style.visibility= "hidden";
								});
						}

						if (edges[pair]["distance"] == "Distant") {
						 //console.log("dis")
							//draw lines for the links
							var line = d3.select("svg")
								.append("line")
								.attr("class", d.id)
								.attr("id", lineId)
								.attr("stroke", "grey")
								.attr("stroke-width", 2)
								.attr("stroke-dasharray", "10,10")
								.attr("opacity", 0.10)
								.attr("x1", edges[pair].optimized_source[0])
								.attr("y1", edges[pair].optimized_source[1])
								.attr("x2", edges[pair].optimized_source[0])
								.attr("y2", edges[pair].optimized_source[1])
								.on("mouseover",function(){
									d3.selectAll("#edgeLabel"+$(this).attr("class")+"-"+this.id).transition().attr("opacity",0.75);
									document.getElementById("heuristicTable").style.visibility= "visible";
								})
								.on("mouseout",function(){
									d3.selectAll("#edgeLabel"+$(this).attr("class")+"-"+this.id).transition().attr("opacity",0)
									document.getElementById("heuristicTable").style.visibility= "hidden";
								})
								.transition()
								.duration(500)
								.attr("x2", edges[pair].optimized_target[0])
								.attr("y2", edges[pair].optimized_target[1]);

							// get equidistant point to place text on edge
							var midX = (200 + edges[pair].source[0] * 0.75 *(width-200)) + ((200 + edges[pair].target[0] * 0.75 *(width-200)) - (200 + edges[pair].source[0] * 0.75 *(width-200))) * 0.50;
							var midY= (150 + edges[pair].source[1] * 0.75 *(height-200)) + ((150 + edges[pair].target[1] * 0.75 *(height-200)) - (150 + edges[pair].source[1] * 0.75 *(height-200))) * 0.50;

							var edgeLabel = d3.select("svg")
								.append("text")
								.attr("class", "edgeLabel"+d.id)
								.attr("id","edgeLabel"+d.id+"-"+lineId)
								.attr('text-anchor', 'middle')
								.attr("x", midX)
								.attr("y", midY)
								.attr("opacity", 0)//.transition().duration(250).attr("opacity", 0.75)
								.attr("fill", "#4c6d92")
								.attr("font-size", 10)
								.text(edges[pair].distance)
								.on("mouseover",function(){
									d3.selectAll("#"+this.id).transition().attr("opacity",0.75);
									document.getElementById("heuristicTable").style.visibility= "visible";
								})
								.on("mouseout",function(){
									d3.selectAll("#"+this.id).transition().attr("opacity",0);
									document.getElementById("heuristicTable").style.visibility= "hidden";
								});
						}

					lineId += 1;
				}
			}
			d3.selectAll('line').lower();
			d3.selectAll('#background_rect').lower();
			//var svg = document.querySelector("svg");
			//var circles = document.querySelectorAll("circle");
			//var text = document.querySelectorAll("text");
			//var menu = d3.select('.context-menu');
			//var rect = menu['_groups'][0][0].getBoundingClientRect();
			//var document_container = '';
			//if(document.getElementById('contextMenu_documents') !== null){
			//	 document_container = document.getElementById('contextMenu_documents');
			//}
			//d3.select('.context-menu').remove();
			//d3.select('foreignObject').remove();
			//// //add circles over edges
			//for(var i = 0; i < circles.length; i++){
			//	svg.appendChild(circles[i]);
			//}
			//var text = document.querySelectorAll("text");
			//for(var i = 0; i < text.length; i++){
			//	svg.appendChild(text[i]);
			//}
			//svg.appendChild(menu['_groups'][0][0]);
			//if(document_container !== ''){
			//	svg.appendChild(document_container);
			//}


	}

	function drawArc(d) {
		let pathGen1 = (x, y, r) => {
				var path = d3.path();
				path.arc(x, y, r, Math.PI * 35/24, Math.PI * 37/24)
				//path.moveTo(x - 10, y)
				//path.lineTo(x, y)
				path.closePath()
				return path;
			}
		let pathGen = (cx, cy, r) => {
				var path = d3.path()
				path.arc(cx, cy, r, Math.PI * 5/4, Math.PI * 7/4)
				path.closePath()
				return path;
			}
		d3.select('#g_'+d.id).append('path')
			//.attr('d', function(d) { return pathGen1(d.optimized_cx, d.optimized_cy - d.actual_radius * min_resize_factor)})
			//.attr('d', pathGen1(d.optimized_cx, d.optimized_cy - d.actual_radius * min_resize_factor))
			.attr('d', pathGen1(d.optimized_cx, d.optimized_cy, d.actual_radius * min_resize_factor - 5))
			.transition()
			//.attr('d', function(d) { return pathGen(
			.attr('d', pathGen(
					d.optimized_cx,
					d.optimized_cy,
					d.actual_radius * min_resize_factor - 5))
			.attr('fill', 'white')
			.duration(500);

	}

	function mouseover(d, min_resize_factor){
		const selected_bibs = current_selection_trace.current_selected_bibs;
		var edge_text = (opened_edges_id.has(d.id)) ? 'Hide Edges' : 'Show Edges';

		const num_authors = d.keywords.length.toString();
		var num_author_text = num_authors + ' authors';
		if (num_authors == 1) {
			num_author_text = num_authors + ' author';
		}

		const num_docs = Object.keys(d.bibs).length;
		const suffix = (dataset_opt == 'Experts') ? ' expert' : ' document';
		var num_doc_text = num_docs + suffix + 's';
		if (num_docs == 1) {
			num_doc_text = num_docs + suffix;
		}

		var info_text = num_doc_text
		if (entity == 'authors') {
			info_text = num_author_text + `\/${num_docs} docs`
		}

		if(selected_bibs.size>=zoom_in_threshold){
			if(current_selection_trace.level > 0) {
				var menu = contextMenu().items(info_text, 'Show Documents', edge_text, 'Hide All Edges', 'Zoom in', 'Zoom out', 'Close Menu');
			} else {
				var menu = contextMenu().items(info_text, 'Show Documents', edge_text, 'Hide All Edges', 'Zoom in', 'Close Menu');
			}
		}else{
			if(current_selection_trace.level > 0) {
				var menu = contextMenu().items(info_text, 'Show Documents', edge_text, 'Hide All Edges', 'Zoom out', 'Close Menu');
			} else {
				var menu = contextMenu().items(info_text, 'Show Documents', edge_text, 'Hide All Edges', 'Close Menu');
			}
		}
		//menu(d.optimized_cx - d.actual_radius * min_resize_factor, d.optimized_cx + d.actual_radius * min_resize_factor, d.optimized_cy - 0.5 * d.actual_radius * min_resize_factor, d.id);
		if (opened_id != d.id) {
			menu(d.optimized_cx, d.optimized_cx + d.actual_radius * min_resize_factor, d.optimized_cy - 0.5 * d.actual_radius * min_resize_factor, d.id);
			opened_id = d.id;
		}

		var width = 1.0*document.getElementById("cluster").offsetWidth;
		var height = document.getElementById("cluster").offsetHeight;

		if (d.id == undefined){
			//console.log(this.id);
			id = this.id.slice(-1)
			var type = "tab";
		} else {
			id = d.id;
			var type = "circle";
		}
//		d3.selectAll('circle').each(function(d){
//			if (d.id == id){
//			var cx = Number($(this).attr('cx'));
//			var cy = Number($(this).attr('cy'));
//			var r = Number($(this).attr('r'));
//
//			const num_authors = d.keywords.length.toString();
//			var num_author_text = num_authors + ' authors';
//			if (num_authors == 1) {
//				num_author_text = num_authors + ' author';
//			}
//
//			const num_docs = Object.keys(d.bibs).length;
//			const suffix = (dataset_opt == 'Experts') ? ' expert' : ' document';
//			var num_doc_text = num_docs + suffix + 's';
//			if (num_docs == 1) {
//				num_doc_text = num_docs + suffix;
//			}
//
//			d3.select('svg')
//				.append('rect')
//				.attr('class', 'contextMenu_tooltip_rect')
//				.attr('id', 'contextMenu_tooltip')
//				.attr('x', cx+r/2-2)
//				.attr('y', cy+2*r/3-11)
//				.style('height','25')
//				.style('width','80')
//				.style('fill','white')
//				.style('opacity','0%');
//			if (entity == 'authors') {
//            	d3.select('svg')
//            	     .append('text')
//            	     .text(num_author_text)
//            	     .attr('class', 'contextMenu_tooltip_text')
//            	     .attr('id', 'contextMenu_tooltip')
//            	     .attr('x', cx+r/2)
//            	     .attr('y', cy+2*r/3)
//            	     .style('font-size','16px')
//            	     .style('fill','dodgerblue');
//
//            	d3.select('svg')
//            	     .append('text')
//            	     .text(num_doc_text)
//            	     .attr('class', 'contextMenu_tooltip_text')
//            	     .attr('id', 'contextMenu_tooltip')
//            	     .attr('x', cx+r/2)
//            	     .attr('y', cy+2*r/3+15)
//            	     .style('font-size','16px')
//            	     .style('fill','dodgerblue');
//				//d3.select('svg')
//				//	.append('text')
//				//	.text('Right click for')
//				//	.attr('class', 'contextMenu_tooltip_text')
//				//	.attr('id', 'contextMenu_tooltip')
//				//	.attr('x', cx+r/2)
//				//	.attr('y', cy+2*r/3+30)
//				//	.style('font-size','16px')
//				//	.style('fill','dodgerblue');
//				//d3.select('svg')
//				//	.append('text')
//				//	.text('more options')
//				//	.attr('class', 'contextMenu_tooltip_text')
//				//	.attr('id', 'contextMenu_tooltip')
//				//	.attr('x', cx+r/2)
//				//	.attr('y', cy+2*r/3+45)
//				//	.style('font-size','16px')
//				//	.style('fill','dodgerblue');
//			} else {
//            	d3.select('svg')
//            	     .append('text')
//            	     .text(num_doc_text)
//            	     .attr('class', 'contextMenu_tooltip_text')
//            	     .attr('id', 'contextMenu_tooltip')
//            	     .attr('x', cx+r/2)
//            	     .attr('y', cy+2*r/3)
//            	     .style('font-size','16px')
//            	     .style('fill','dodgerblue');
//				//d3.select('svg')
//				//	.append('text')
//				//	.text('Right click for')
//				//	.attr('class', 'contextMenu_tooltip_text')
//				//	.attr('id', 'contextMenu_tooltip')
//				//	.attr('x', cx+r/2)
//				//	.attr('y', cy+2*r/3+15)
//				//	.style('font-size','16px')
//				//	.style('fill','dodgerblue');
//				//d3.select('svg')
//				//	.append('text')
//				//	.text('more options')
//				//	.attr('class', 'contextMenu_tooltip_text')
//				//	.attr('id', 'contextMenu_tooltip')
//				//	.attr('x', cx+r/2)
//				//	.attr('y', cy+2*r/3+30)
//				//	.style('font-size','16px')
//				//	.style('fill','dodgerblue');
//			}
	//  d3.event.preventDefault();
	//  d3.select('svg').append("foreignObject")
	// 												.attr("id", "contextMenu_documents")
	// 												.attr("class", "contextMenu__documents")
	// 												.attr("class", "contextMenu__documents")
	// 												.attr('x', (cx+r/2)+100)
	// 												.attr('y', (cy+2*r/3+11)-150)
	// 												.attr("width", 300)
	// 												.attr("height", 400)
	// 												.style("background-color", "rgba(255,255,255,.2)")
	// 												.style("border", "solid")
	// 												.style("border-color", "lightgrey")
	// 												.style("padding", "5px")
	// 												.style("font-size", "13px")
	// 												.style("text-align", "left")
	// 												.append("xhtml:div")
	// 												.attr("id", "documentContainer")
	// 												.attr("class", "documentContainer")
	// 												.style("max-height", "400px")
	// 												.style("overflow-y", "scroll");
	// 												showDocuments(d);
	// 												console.log(cx+r/2);
	// 												console.log(cy+2*r/3+11);

//		 }
		 // else{
			//  this.style.stroke = "none";
		 // }
//	 });

	}

	async function copyCitations(d){
        // const response = await fetch("https://eutils.ncbi.nlm.nih.gov/entrez/eutils/esummary.fcgi?db=pubmed&id=33414254&retmode=json");
        // const data = await response.json();
        // console.log(data.result);
        alert("Citations copied to clipboard");
        //console.log("Citation copied!");
        var database = "pubmed";
        var url = "https://eutils.ncbi.nlm.nih.gov/entrez/eutils/esummary.fcgi?";
        var bibs_length = d.members.length;
        citations = ""
        // const response = await fetch(`https://eutils.ncbi.nlm.nih.gov/entrez/eutils/esummary.fcgi?db=pubmed&id=33422827&retmode=json`);
        // const data = await response.json();
        // console.log(data.response);
        var paragraph = document.getElementById('citation');
		// var string = d.bibs[i].html.split('=')[1];
		// console.log(d.bibs)
		// var jqXHR = $.ajax({
        //     type: "POST",
        //     url: "/citations",
        //     async: true,
        //     data: { mydata: "hello"}
        // 	});

		// console.log(jqXHR);
        for (var i = 0; i<bibs_length; i++){
            var string = d.bibs[i].html.split('=')[1];
			var jqXHR = $.ajax({
            type: "POST",
            url: "/citations",
            async: true,
            data: { mydata: string}
        	});
			//console.log(string);
			// console.log(jqXHR);
			// console.log(setTimeoucitationGenerator(string));
			// var temp = setTimeout(citationGenerator(string), 3000);
			var temp = setTimeout(function () {
									var resp = $.ajax({
            						type: "POST",
            						url: "/citations",
            						async: true,
            						data: { mydata: id}
        						});
								//console.log(resp);
								return resp;
						}, 3000 );
			await sleep(3000);
			//console.log(Object.keys(temp));
			// console.log(setTimeout(citationGenerator(string), 1000));
            // citations += setTimeout(await citationGenerator(string,d.bibs[i].author), 10000000);
            //console.log(d.bibs[i]);
            corrected_title = d.bibs[i].title.replace("\"", "");
            corrected_title = corrected_title.replace("\"", "");
//             citations += d.bibs[i].author + "." + " " + "\"" + corrected_title + "\"";
            citations += "\n"
        }
        const el = document.createElement('textarea');
        el.value = citations;
        el.setAttribute('readonly', '');
        el.style.position = 'absolute';
        el.style.left = '-9999px';
        document.body.appendChild(el);
        el.select();
        document.execCommand('copy');
        document.body.removeChild(el);
}

function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}


function citationGenerator(id){
		var jqXHR = $.ajax({
            type: "POST",
            url: "/citations",
            async: true,
            data: { mydata: id}
        });
		return jqXHR;
}

	function showDocuments(d) {
		// console.log("show Documents");
		var dataset_opt = urlParams.get("dataset_opt");
		var bibs_list = "";
		var bibs_length = d.members.length;
		// console.log("bibs=" + bibs_length);
		var document_array = [];
		var uploaded_document_array = [];
		var citation_dict = {};
		// console.log("bibs length=" + bibs_length);
		// console.log("dataset_opt=" + dataset_opt);
		// print the documents
		// console.log("Documents: "+ JSON.stringify(d));
		for (var j = 0; j < bibs_length; j++) {
			if (d.bibs[j].title == undefined) {
				console.log("titles are undefined")
				var ind = j + 1;
				bibs_list = "";
			} 
			else if (d.bibs[j].html == undefined) {
				console.log("html is undefined")
				var ind = j + 1;
				var pmid = d.bibs[j].pmid;
				//console.log(d.bibs[j].author)
				body_toshow = d.bibs[j].body_toshow;
				if (pmid == undefined) {
					if (body_toshow != undefined) {
						//console.log("body_toshow is not undefined")
						body_toshow = body_toshow.replace(/'/g, "_singlequote_");
						body_toshow = body_toshow.replace(/"/g, "_doublequote_");
						body_toshow = body_toshow.replace(/\n/g, " _startinganewline_ ");
						bibs_list =
							bibs_list +
							"<br>" +
							'<a href=# class = "text_link" id="text_link' +
							ind +
							'" onclick="show_uploaded_articles(\'' +
							body_toshow +
							"','text_link" +
							ind +
							"')\" >" +
							d.bibs[j].title +
							"</a> <br>";
						uploaded_document_array.push(
							'<a href=# class = "text_link" id="text_link' +
								ind +
								'" onclick="show_uploaded_articles(\'' +
								body_toshow +
								"','text_link" +
								ind +
								"')\" >" +
								d.bibs[j].title +
								"</a> <br>",
						);
					} else {
						bibs_list =
							bibs_list +
							"<br>" +
							"<a href =" +
							'"https://www.ncbi.nlm.nih.gov/pubmed/?term=' +
							d.bibs[j].title +
							'%5Buid%5D" onclick="return !window.open(this.href, \'somesite\', \'width=1000,height=700\')"target="_blank" >' +
							d.bibs[j].title +
							"</a> <br>" +
							d.bibs[j].author +
							"<br>" +
							d.bibs[j].journal +
							"<br>" +
							d.bibs[j].pdate +
							"<br>" +
							"</br>";
					}
				} else {
					bibs_list =
						bibs_list +
						"<br>" +
						`<a href =` +
						'"https://www.ncbi.nlm.nih.gov/pubmed/?term=' +
						pmid +
						'%5Buid%5D" onclick="return !window.open(this.href, \'somesite\', \'width=1000,height=700\')"target="_blank" >' +
						d.bibs[j].title +
						"</a> <br>" +
						d.bibs[j].author +
						"<br>" +
						d.bibs[j].journal +
						"<br>" +
						d.bibs[j].pdate +
						"<br>" +
						"</br>";
				}
			} 
			else {
				bibs_list =
					bibs_list +
					"<br>" +
					'<a href ="' +
					d.bibs[j].html +
					'" onclick="return !window.open(this.href, \'somesite\', \'width=1000,height=700\')"target="_blank">' +
					d.bibs[j].title +
					"</a> <br>";
				// bibs_list = bibs_list + d.bibs[j].abstract + "<br>";
				bibs_list = bibs_list + "<br>";
				//create div to put title, authors, and citation button in
				var div = document.createElement("div");
				var a = document.createElement("a");
				a.innerHTML = "\n";
				a.innerHTML +=
					'<a href ="' +
					d.bibs[j].html +
					'" onclick="return !window.open(this.href, \'somesite\', \'width=1000,height=700\')"target="_blank">' +
					d.bibs[j].title +
					"</a> <br>";
				div.appendChild(a);
				let author_string = "";
				if (dataset_opt == "PubMedAPI") {
					for (var element in d.bibs[j]) {
						if (element == "author" || element == "authors") {
							//console.log("element is " + d.bibs[j][element] )
							if (d.bibs[j][element].length == 0) {
								var p = document.createElement("p");
								p.innerHTML = "<i> No authors listed<i/>";
								div.appendChild(p);
								bibs_list = bibs_list + "<i> No authors listed<i/>" + "<br>";
							} else if (d.bibs[j][element].length > 5) {
								var n = 5;
								console.log("LAIR", d.bibs[j][element]);
								console.log("LAIR", d.bibs[j][element].length);
								const array = d.bibs[j][element].slice(0, n);
								console.log(array);
								author_string = array.join(",");
								author_string = author_string.slice(0, -1);
								author_string += `...${d.bibs[j][element][d.bibs[j][element].length - 1]}`;
								var p = document.createElement("p");
								p.innerHTML = author_string;
								div.appendChild(p);
								array.push(
									`...${d.bibs[j][element][d.bibs[j][element].length - 1]}`,
								);
								var btn = document.createElement("button");
								btn.innerHTML = '""';
								btn.style.backgroundColor = "#4c6d92";
								btn.style.opacity = 0.7;
								btn.style.color = "white";
								btn.style.border = "none";
								btn.style.borderRadius = "4px";
								bibs_list = bibs_list + author_string + "<br>" + btn;
							} else {
								var p = document.createElement("p");
								p.innerHTML = d.bibs[j][element];
								div.appendChild(p);
								string = d.bibs[j][element].join(",");
								bibs_list = bibs_list + d.bibs[j][element] + "<br>";
							}
						}
					}
					var btn = document.createElement("button");
					btn.setAttribute("title", "copy citation to clipboard");
					// btn.innerHTML = '<i class="far fa-copy"></i>';
					btn.style.backgroundColor = "#4c6d92";
					btn.style.color = "white";
					btn.style.opacity = 0.7;
					btn.style.border = "none";
					btn.style.borderRadius = "4px";
					btn.style.display = "inline";
					btn.style.marginTop = "-12px";
					btn.style.marginBottom = "12px";
					btn.style.height = "15px";
					var temp = d.bibs[j];
					btn.setAttribute("class", `${temp.title}`);
					var temp1 = "";
					var string = "";
					var authors = temp.author;
					var author_list = [];
					for (let i = 0; i < authors.length; i++) {
						let author = authors[i].split(" ");
						author = author[author.length - 1] + "," + " " + author[0];
						//console.log(author);
						author_list.push(author);
					}

					authors = author_list.join(" and ");
					var first_name = "";
					if (authors.length !== 0) {
						var first_name = authors[0]
							.split(" ")
							[authors[0].split(" ").length - 1].toLowerCase();
					}
					var title = temp.title;
					var title_first_word = title.split(" ")[0].toLowerCase();
					var journal = temp.journal;
					var year = temp.pubyear.slice(0, -2);
					var volume = temp.volume;
					if (first_name == "") {
						string = `@article{${first_name}${year}${title_first_word},\n  title={${title}},\n  journal={${journal}},\n  year={${year}}}`;
						temp1 = string;
					} else {
						string = `@article{${first_name}${year}${title_first_word},\n  title={${title}},\n  author={${authors}},\n  journal={${journal}},\n  year={${year}}}`;
						temp1 = string;
					}
					div.appendChild(btn);
					var br = document.createElement("br");
					div.appendChild(br);
					div.appendChild(br);
					//add div with title, author and button to array of all divs
					citation_dict[temp.title] = string;
					//console.log(string);
					//console.log(`temp1${temp1}`);
					document_array.push(div);
				} 
				else if (dataset_opt == "NewsAPI") {
					for (var element in d.bibs[j]) {
						if (element == "journal") {
							var p = document.createElement("p");
							p.innerHTML = d.bibs[j][element];
							div.appendChild(p);
							//string = d.bibs[j][element].join(',');
							bibs_list = bibs_list + d.bibs[j][element] + "<br>";
						} else if (element == "author" || element == "authors") {
							if (d.bibs[j][element] == "None") {
								d.bibs[j][element] = "No Author Listed";
							}
							//console.log("element is " + d.bibs[j][element] )
							if (d.bibs[j][element].length == 0) {
								var p = document.createElement("p");
								p.innerHTML = "<i> No authors listed<i/>";
								div.appendChild(p);
								bibs_list = bibs_list + "<i> No authors listed<i/>" + "<br>";
							} else {
								var p = document.createElement("p");
								p.innerHTML = d.bibs[j][element];
								div.appendChild(p);
								//string = d.bibs[j][element].join(',');
								bibs_list = bibs_list + d.bibs[j][element] + "<br>";
							}
						}
					}
					var btn = document.createElement("button");
					btn.setAttribute("title", "copy citation to clipboard");
					// btn.innerHTML = '<i class="far fa-copy"></i>';
					btn.style.backgroundColor = "#4c6d92";
					btn.style.color = "white";
					btn.style.opacity = 0.7;
					btn.style.border = "none";
					btn.style.borderRadius = "4px";
					btn.style.display = "inline";
					btn.style.marginTop = "-12px";
					btn.style.marginBottom = "12px";
					btn.style.height = "15px";
					var temp = d.bibs[j];
					btn.setAttribute("class", `${temp.title}`);
					var temp1 = "";
					var string = "";
					var authors = temp.author;
					var author_list = [];
					for (let i = 0; i < authors.length; i++) {
						let author = authors[i].split(" ");
						author = author[author.length - 1] + "," + " " + author[0];
						//console.log(author);
						author_list.push(author);
					}

					authors = author_list.join(" and ");
					var first_name = "";
					if (authors.length !== 0) {
						var first_name = authors[0]
							.split(" ")
							[authors[0].split(" ").length - 1].toLowerCase();
					}
					var title = temp.title;
					var title_first_word = title.split(" ")[0].toLowerCase();
					var journal = temp.journal;
					if (temp.pubyear != undefined) {
						var year = temp.pubyear.slice(0, -2);
					}
					var volume = temp.volume;
					if (first_name == "") {
						string = `@article{${first_name}${year}${title_first_word},\n  title={${title}},\n  journal={${journal}},\n  year={${year}}}`;
						temp1 = string;
					} else {
						string = `@article{${first_name}${year}${title_first_word},\n  title={${title}},\n  author={${authors}},\n  journal={${journal}},\n  year={${year}}}`;
						temp1 = string;
					}
					div.appendChild(btn);
					var br = document.createElement("br");
					div.appendChild(br);
					div.appendChild(br);
					//add div with title, author and button to array of all divs
					citation_dict[temp.title] = string;
					//console.log(string);
					//console.log(`temp1${temp1}`);
					document_array.push(div);
				}
				else if (dataset_opt == "PostgreSQL") {
					// console.log("PostgresSQL");

					// Create a div for each bib
					var div = document.createElement("div");

					// Display only the title and the HTML link
					var title = d.bibs[j].title ?? "No Title Available"; // Use a fallback if the title is undefined
					var html_link = d.bibs[j].html ?? "#"; // Use a fallback if the HTML link is undefined

					// Create the title as a clickable link
					var link = document.createElement("a");
					// link.setAttribute("href", html_link); // Set the href to the HTML link
					// link.setAttribute("target", "_blank"); // Open link in a new tab
					link.innerHTML = title; // Set the title as the link text
					link.style.padding = "5px";
					link.style.color = "#4c6d92";
					link.style.cursor = "pointer";
					// Append the link to the div
					div.appendChild(link);
					link.addEventListener('click',function(){
						window.open(html_link, 'newwindow', 'width=500,height=450')
						return false;
					})
					// Add the "Copy Citations" button
					var btn = document.createElement("button");
					btn.setAttribute("title", "Copy citation to clipboard");
					// btn.innerHTML = '<i class="far fa-copy"></i>'; // Copy icon
					btn.style.backgroundColor = "#4c6d92";
					btn.style.color = "white";
					btn.style.opacity = 0;
					btn.style.border = "none";
					btn.style.borderRadius = "4px";
					btn.style.display = "inline";
					btn.style.marginLeft = "10px"; // Add some space between the link and button
					btn.style.marginTop = "-12px";
					btn.style.marginBottom = "12px";
					btn.style.height = "15px";
					btn.style.padding = "5px";

					// Create the citation text
					var citation = `@article{${title.split(" ")[0].toLowerCase()},\n  title={${title}},\n  link={${html_link}}}`;
					
					// Add an event listener to copy the citation to clipboard when the button is clicked
					btn.addEventListener("click", function () {
						const el = document.createElement("textarea");
						el.value = citation; // Set the citation text to the textarea
						el.setAttribute("readonly", "");
						el.style.position = "absolute";
						el.style.left = "-9999px";
						document.body.appendChild(el);
						el.select();
						document.execCommand("copy");
						document.body.removeChild(el);
						alert("Citation has been copied to clipboard");
					});

					// Append the copy button to the div
					div.appendChild(btn);

					// Optionally, add a break between links for readability
					var br = document.createElement("br");
					div.appendChild(br);

					// Add div to the document array
					document_array.push(div);

					// Store citation in citation_dict for use with the copy button
					citation_dict[title] = citation;
				}
			}
		}
		//documents
		var container = document.getElementById("documentContainer");
		container.style.backgroundColor = "rgb(244,244,244)";
		// print the dataset
		console.log("The dataset is " + dataset_opt);
		if (dataset_opt !== "PubMedAPI" && dataset_opt !== "NewsAPI" && dataset_opt !== "PostgreSQL") {
			// console.log("Not PubMedAPI or NewsAPI or PostgresSQL");
			container.innerHTML =
				'<h3 style="color:#4c6d92;opacity:0.75; padding:5px;">Clustered Publications</h3>' +
				"\n<p>" +
				bibs_list +
				"</p>";
			console.log(container);
			console.log(d.bibs[j].abstract);
		} 
		else if (dataset_opt == "PostgreSQL") {
			// console.log("PostgreSQL");
			// print document array
			// console.log(document_array);
			var btn = document.createElement("button");
			btn.setAttribute("id", "citationButton");
			// btn.innerHTML = '<i class="far fa-copy"></i> Copy';
			btn.style.backgroundColor = "#4c6d92";
			btn.style.opacity = 0;
			btn.style.color = "white";
			btn.style.border = "none";
			btn.style.borderRadius = "4px";
			btn.style.marginBottom = "25px";
			btn.setAttribute("title", "copy all to clipboard");


			document.getElementById("documentContainer").innerHTML +=
				'<h3 style="color:#4c6d92;opacity:0.75">Clustered Articles </h3>';
			// Add another button to
			document.getElementById("documentContainer").appendChild(btn);
			var br = document.createElement("br");
			document.getElementById("documentContainer").appendChild(br);

			// Button to copy all citations
			document.getElementById("citationButton").onclick = function () {
				var citations = "";  // This will store all citations
				for (let title in citation_dict) {
					citations += citation_dict[title] + "\n\n"; // Concatenate each citation
				}

				// If citations are not empty, copy them to clipboard
				if (citations) {
					const el = document.createElement("textarea");
					el.value = citations;
					el.setAttribute("readonly", "");
					el.style.position = "absolute";
					el.style.left = "-9999px";  // Hide the textarea off-screen
					document.body.appendChild(el);
					el.select();
					document.execCommand("copy");
					document.body.removeChild(el);
					alert("All citations have been copied to clipboard");
				} else {
					alert("No citations available to copy.");
				}
			};

			//  createCitations("documentContainer", d);
			// container.innerHTML += '\n<p>'+bibs_list+'</p>';
			// add all divs with document information to container
			for (let i = 0; i < document_array.length; i++) {
				var temp = document_array[i]["childNodes"][2];
				//console.log(document_array[i]);
				temp.addEventListener("click", function () {
					const el = document.createElement("textarea");
					el.value = citation_dict[this.className];
					el.setAttribute("readonly", "");
					el.style.position = "absolute";
					el.style.left = "-9999px";
					document.body.appendChild(el);
					el.select();
					document.execCommand("copy");
					document.body.removeChild(el);
					alert("Citation has been copied to clipboard");
				});
				container.appendChild(document_array[i]);
			
			}
		}
		else {
			// console.log("Not PubMedAPI or NewsAPI or PostgresSQL");
			var btn = document.createElement("button");
			btn.setAttribute("id", "citationButton");
			btn.innerHTML = '<i class="far fa-copy"></i> Copy ';
			btn.style.backgroundColor = "#4c6d92";
			btn.style.opacity = 0.7;
			btn.style.color = "white";
			btn.style.border = "none";
			btn.style.borderRadius = "4px";
			btn.style.marginBottom = "25px";
			btn.setAttribute("title", "copy all citations to clipboard");
			document.getElementById("documentContainer").innerHTML +=
				'<h3 style="color:#4c6d92;opacity:0.75">Clustered Publications </h3>';
			// Add another button to
			document.getElementById("documentContainer").appendChild(btn);
			var br = document.createElement("br");
			document.getElementById("documentContainer").appendChild(br);
			//  createCitations("documentContainer", d);
			// container.innerHTML += '\n<p>'+bibs_list+'</p>';
			// add all divs with document information to container
			for (let i = 0; i < document_array.length; i++) {
				var temp = document_array[i]["childNodes"][2];
				//console.log(document_array[i]);
				temp.addEventListener("click", function () {
					const el = document.createElement("textarea");
					el.value = citation_dict[this.className];
					el.setAttribute("readonly", "");
					el.style.position = "absolute";
					el.style.left = "-9999px";
					document.body.appendChild(el);
					el.select();
					document.execCommand("copy");
					document.body.removeChild(el);
					alert("Citation has been copied to clipboard");
				});
				container.appendChild(document_array[i]);
			}
			//console.log(citation_dict);
			// button to copy all citations
			document.getElementById("citationButton").onclick = function () {
				//console.log('copy');
				document.execCommand("copy");
				var bibs_length = d.members.length;
				var citations = "";
				for (var j = 0; j < bibs_length; j++) {
					var authors = d.bibs[j].author;
					var author_list = [];
					for (let i = 0; i < authors.length; i++) {
						let author = authors[i].split(" ");
						author = author[author.length - 1] + "," + " " + author[0];
						//console.log(author);
						author_list.push(author);
					}
					authors = author_list.join(" and ");
					var first_name = "";
					if (authors.length !== 0) {
						var first_name = authors[0]
							.split(" ")
							[authors[0].split(" ").length - 1].toLowerCase();
					}
					var title = d.bibs[j].title;
					console.log(d.bibs[j].abstract);
					var title_first_word = title.split(" ")[0].toLowerCase();
					var journal = d.bibs[j].journal;
					var year = d.bibs[j].pubyear.slice(0, -2);
					var volume = d.bibs[j].volume;
					if (first_name == "") {
						var string1 = `@article{${first_name}${year}${title_first_word},\n  title={${title}},\n  journal={${journal}},\n  year={${year}}}`;
					} else {
						var string1 = `@article{${first_name}${year}${title_first_word},\n  title={${title}},\n  author={${authors}},\n  journal={${journal}},\n  year={${year}}}`;
					}
					string1 += "\n\n";
					citations += string1;
					const el = document.createElement("textarea");
					el.value = citations;
					el.setAttribute("readonly", "");
					el.style.position = "absolute";
					el.style.left = "-9999px";
					document.body.appendChild(el);
					el.select();
					document.execCommand("copy");
					document.body.removeChild(el);
				}
				alert("Citations have been copied to clipboard");
			};
		}
		// display mesh terms for current cluster
		//const meshTerms = {{session['id2meshTerms']|tojson}}
		//const meshTermString = meshTerms[d.id]
		//document.getElementById("documentContainer").innerHTML += `<p style="color:black;opacity:0.75">${meshTermString}</p>`;
	}


	// function showDocuments(d){
	// 	console.log('show Documents');
	// 	var dataset_opt = urlParams.get('dataset_opt');
	// 	 var bibs_list = '';
	// 	 var bibs_length = d.members.length;
	// 	 console.log("bibs="+bibs_length);
	// 	 var document_array = [];
	// 	 var uploaded_document_array = [];
	// 	 var citation_dict = {};
	// 	 for (var j=0; j<bibs_length; j++){
	// 		 if(d.bibs[j].title == undefined){
	// 			 //console.log("titles are undefined")
	// 			 var ind = j+1;
	// 			 bibs_list = '';
	// 		 }else if (d.bibs[j].html == undefined){
	// 			 //console.log("html is undefined")
	// 			 var ind = j+1;
	// 			 var pmid = d.bibs[j].pmid;
	// 			 //console.log(d.bibs[j].author)
	// 			 body_toshow = d.bibs[j].body_toshow;
	// 			 if (pmid == undefined){
	// 				 if (body_toshow != undefined){
	// 					 //console.log("body_toshow is not undefined")
	// 					 body_toshow = body_toshow.replace(/'/g, '_singlequote_');
	// 					 body_toshow = body_toshow.replace(/"/g, '_doublequote_');
	// 					 body_toshow = body_toshow.replace(/\n/g, ' _startinganewline_ ');
	// 					 bibs_list = bibs_list + '<br>' + '<a href=# class = "text_link" id="text_link'+ind+'" onclick="show_uploaded_articles(\''+ body_toshow + '\',\'text_link'+ind+'\')" >' + d.bibs[j].title + '</a> <br>';
	// 					 uploaded_document_array.push('<a href=# class = "text_link" id="text_link'+ind+'" onclick="show_uploaded_articles(\''+ body_toshow + '\',\'text_link'+ind+'\')" >' + d.bibs[j].title + '</a> <br>');
	// 				 }else{
	// 					 bibs_list = bibs_list + '<br>' + '<a href =' + '"https://www.ncbi.nlm.nih.gov/pubmed/?term=' + d.bibs[j].title + '%5Buid%5D" onclick="return !window.open(this.href, \'somesite\', \'width=1000,height=700\')"target="_blank" >' + d.bibs[j].title + '</a> <br>'+ d.bibs[j].author + '<br>'+ d.bibs[j].journal + '<br>'+ d.bibs[j].pdate + '<br>' + '</br>';
	// 				 }
	// 			 }else{
	// 				 bibs_list = bibs_list + '<br>' + `<a href =` + '"https://www.ncbi.nlm.nih.gov/pubmed/?term=' + pmid + '%5Buid%5D" onclick="return !window.open(this.href, \'somesite\', \'width=1000,height=700\')"target="_blank" >' + d.bibs[j].title + '</a> <br>'+ d.bibs[j].author + '<br>'+ d.bibs[j].journal + '<br>'+ d.bibs[j].pdate + '<br>' + '</br>';
	// 			 }
	// 		 }else{
	// 			bibs_list = bibs_list + '<br>' + '<a href ="' + d.bibs[j].html + '" onclick="return !window.open(this.href, \'somesite\', \'width=1000,height=700\')"target="_blank">' + d.bibs[j].title + '</a> <br>'
    //     bibs_list = bibs_list + d.bibs[j].abstract + '<br>'
	// 			//create div to put title, authors, and citation button in
	// 			var div = document.createElement('div');
	// 			var a = document.createElement('a');
	// 			a.innerHTML = '\n';
	// 			a.innerHTML += '<a href ="' + d.bibs[j].html + '" onclick="return !window.open(this.href, \'somesite\', \'width=1000,height=700\')"target="_blank">' + d.bibs[j].title + '</a> <br>';
	// 			div.appendChild(a);
	// 			let author_string = '';
	// 			if(dataset_opt == 'PubMedAPI'){
	// 				for (var element in d.bibs[j]){
	// 					if (element == 'author' || element == 'authors'){
	// 						//console.log("element is " + d.bibs[j][element] )
	// 						if(d.bibs[j][element].length == 0){
	// 						   var p = document.createElement('p');
	// 						   p.innerHTML = '<i> No authors listed<i/>';
	// 						   div.appendChild(p);
	// 						   bibs_list = bibs_list + '<i> No authors listed<i/>' + '<br>'
	// 						}
	// 						else if(d.bibs[j][element].length > 5){
	// 							var n = 5;
	// 							console.log("LAIR",d.bibs[j][element]);
	// 							console.log("LAIR",d.bibs[j][element].length);
	// 							const array = d.bibs[j][element].slice(0,n);
	// 							console.log(array);
	// 							author_string = array.join(',');
	// 							author_string = author_string.slice(0,-1);
	// 							author_string += `...${d.bibs[j][element][d.bibs[j][element].length-1]}`;
	// 							var p = document.createElement('p');
	// 						   p.innerHTML = author_string;
	// 						   div.appendChild(p);
	// 							array.push(`...${d.bibs[j][element][d.bibs[j][element].length-1]}`);
	// 							var btn = document.createElement('button');
	// 							btn.innerHTML = '""';
	// 							btn.style.backgroundColor = 'dodgerblue';
	// 							btn.style.opacity = 0.7;
	// 							btn.style.color = 'white';
	// 							btn.style.border ='none';
	// 							btn.style.borderRadius = '4px';
	// 							bibs_list = bibs_list + author_string + '<br>' + btn;
	// 						}
	// 						else{
	// 						   var p = document.createElement('p');
	// 						   p.innerHTML = d.bibs[j][element];
	// 						   div.appendChild(p);
	// 						   string = d.bibs[j][element].join(',');
	// 							bibs_list = bibs_list + d.bibs[j][element] + '<br>'

	// 						}

	// 					}
	// 				}
	// 				var btn = document.createElement('button');
	// 				btn.setAttribute('title', 'copy citation to clipboard');
	// 				btn.innerHTML = '<i class="far fa-copy"></i>';
	// 				btn.style.backgroundColor = 'dodgerblue';
	// 				btn.style.color = 'white';
	// 				 btn.style.opacity = 0.7;
	// 			   btn.style.border ='none';
	// 			   btn.style.borderRadius = '4px';
	// 			   btn.style.display = 'inline';
	// 			   btn.style.marginTop = '-12px';
	// 			   btn.style.marginBottom = '12px';
	// 			   btn.style.height = '15px';
	// 			   var temp = d.bibs[j];
	// 			   btn.setAttribute('class', `${temp.title}`);
	// 			   var temp1 = '';
	// 			   var string = ''
	// 			   var authors = temp.author;
	// 			   var author_list = [];
	// 			   for(let i = 0; i<authors.length; i++){
	// 				   let author = authors[i].split(" ");
	// 				   author = author[author.length-1] + "," + " " + author[0]
	// 				   //console.log(author);
	// 				   author_list.push(author);
	// 			   }

	// 			   authors = author_list.join(" and ");
	// 				   var first_name = '';
	// 				   if (authors.length !== 0){
	// 					   var first_name = authors[0].split(" ")[authors[0].split(" ").length-1].toLowerCase();
	// 				   }
	// 				   var title = temp.title;
	// 				   var title_first_word = title.split(" ")[0].toLowerCase();
	// 				   var journal = temp.journal;
	// 				   var year = temp.pubyear.slice(0,-2);
	// 				   var volume = temp.volume;
	// 				   if(first_name == ''){
	// 						string = `@article{${first_name}${year}${title_first_word},\n  title={${title}},\n  journal={${journal}},\n  year={${year}}}`;
	// 					   temp1 = string;
	// 				   }
	// 				   else{
	// 					string = `@article{${first_name}${year}${title_first_word},\n  title={${title}},\n  author={${authors}},\n  journal={${journal}},\n  year={${year}}}`;
	// 				   temp1= string;

	// 				   }
	// 			   div.appendChild(btn);
	// 			   var br = document.createElement('br');
	// 			   div.appendChild(br);
	// 			   div.appendChild(br);
	// 			   //add div with title, author and button to array of all divs
	// 			   citation_dict[temp.title] = string;
	// 			   //console.log(string);
	// 			   //console.log(`temp1${temp1}`);
	// 			   document_array.push(div);

	// 			}
	// 			else if(dataset_opt == 'NewsAPI'){
	// 				for (var element in d.bibs[j]){
	// 					if (element == 'journal'){
	// 						var p = document.createElement('p');
	// 						   p.innerHTML = d.bibs[j][element];
	// 						   div.appendChild(p);
	// 						   //string = d.bibs[j][element].join(',');
	// 						   bibs_list = bibs_list + d.bibs[j][element] + '<br>'
	// 					}
	// 					else if (element == 'author' || element == 'authors'){
	// 						if (d.bibs[j][element] == 'None') {
	// 						    d.bibs[j][element] = 'No Author Listed';
	// 						};
	// 						//console.log("element is " + d.bibs[j][element] )
	// 						if(d.bibs[j][element].length == 0){
	// 						   var p = document.createElement('p');
	// 						   p.innerHTML = '<i> No authors listed<i/>';
	// 						   div.appendChild(p);
	// 						   bibs_list = bibs_list + '<i> No authors listed<i/>' + '<br>'
	// 						}
	// 						else{
	// 						   var p = document.createElement('p');
	// 						   p.innerHTML = d.bibs[j][element];
	// 						   div.appendChild(p);
	// 						   //string = d.bibs[j][element].join(',');
	// 						   bibs_list = bibs_list + d.bibs[j][element] + '<br>'

	// 						}

	// 					}
	// 				}
	// 				var btn = document.createElement('button');
	// 				btn.setAttribute('title', 'copy citation to clipboard');
	// 				btn.innerHTML = '<i class="far fa-copy"></i>';
	// 				btn.style.backgroundColor = 'dodgerblue';
	// 				btn.style.color = 'white';
	// 				 btn.style.opacity = 0.7;
	// 			   btn.style.border ='none';
	// 			   btn.style.borderRadius = '4px';
	// 			   btn.style.display = 'inline';
	// 			   btn.style.marginTop = '-12px';
	// 			   btn.style.marginBottom = '12px';
	// 			   btn.style.height = '15px';
	// 			   var temp = d.bibs[j];
	// 			   btn.setAttribute('class', `${temp.title}`);
	// 			   var temp1 = '';
	// 			   var string = ''
	// 			   var authors = temp.author;
	// 			   var author_list = [];
	// 			   for(let i = 0; i<authors.length; i++){
	// 				   let author = authors[i].split(" ");
	// 				   author = author[author.length-1] + "," + " " + author[0]
	// 				   //console.log(author);
	// 				   author_list.push(author);
	// 			   }

	// 			   authors = author_list.join(" and ");
	// 				   var first_name = '';
	// 				   if (authors.length !== 0){
	// 					   var first_name = authors[0].split(" ")[authors[0].split(" ").length-1].toLowerCase();
	// 				   }
	// 				   var title = temp.title;
	// 				   var title_first_word = title.split(" ")[0].toLowerCase();
	// 				   var journal = temp.journal;
	// 				   if (temp.pubyear != undefined) {
	// 				       var year = temp.pubyear.slice(0,-2);
	// 				   };
	// 				   var volume = temp.volume;
	// 				   if(first_name == ''){
	// 						string = `@article{${first_name}${year}${title_first_word},\n  title={${title}},\n  journal={${journal}},\n  year={${year}}}`;
	// 					   temp1 = string;
	// 				   }
	// 				   else{
	// 					string = `@article{${first_name}${year}${title_first_word},\n  title={${title}},\n  author={${authors}},\n  journal={${journal}},\n  year={${year}}}`;
	// 				   temp1= string;

	// 				   }
	// 			   div.appendChild(btn);
	// 			   var br = document.createElement('br');
	// 			   div.appendChild(br);
	// 			   div.appendChild(br);
	// 			   //add div with title, author and button to array of all divs
	// 			   citation_dict[temp.title] = string;
	// 			   //console.log(string);
	// 			   //console.log(`temp1${temp1}`);
	// 			   document_array.push(div);

	// 			}
	// 			 // create citation button and style
	// 			 //if(author == undefined){
	// 				 //bibs_list = bibs_list + '<br>' + '<a href ="' + d.bibs[j].html + '" onclick="return !window.open(this.href, \'somesite\', \'width=1000,height=700\')"target="_blank">' + d.bibs[j].title + '</a> <br>' + d.bibs[j].author + '<br>'+ d.bibs[j].journal + '<br>' + '</br>';
	// 			 //}else{
	// 				 //var ind = j+1
	// 				 //bibs_list = bibs_list + '<br>' + '<a href ="' + d.bibs[j].html + '" onclick="return !window.open(this.href, \'somesite\', \'width=1000,height=700\')"target="_blank">' + d.bibs[j].title + '</a> <br>' + d.bibs[j].author + '<br>'+ d.bibs[j].journal + '<br>' + '</br>';
	// 			 //}
	// 		 }
	// 	 }
	// 	 //documents
	// 	 var container = document.getElementById("documentContainer");
	// 	 container.style.backgroundColor = 'rgb(244,244,244)'
	// 	if(dataset_opt !== 'PubMedAPI' && dataset_opt !== 'NewsAPI'){
	// 		container.innerHTML = '<h3 style="color:DodgerBlue;opacity:0.75">Clustered Publications</h3>' +
	// 																	'\n<p>'+bibs_list+'</p>';
	// 		console.log(container)
    //   console.log(d.bibs[j].abstract)
	// 	}

	// 	else{
	// 		var btn = document.createElement('button');
	// 		btn.setAttribute('id', 'citationButton');
	// 		btn.innerHTML = '<i class="far fa-copy"></i> Copy Citations';
	// 		btn.style.backgroundColor = 'dodgerblue';
	// 		btn.style.opacity = 0.7;
	// 		btn.style.color = 'white';
	// 		btn.style.border ='none';
	// 		btn.style.borderRadius = '4px';
	// 		btn.style.marginBottom = '25px';
	// 		btn.setAttribute('title', 'copy all citations to clipboard');
	// 		document.getElementById("documentContainer").innerHTML += '<h3 style="color:DodgerBlue;opacity:0.75">Clustered Publications </h3>';
	// 		// Add another button to 
	// 		document.getElementById("documentContainer").appendChild(btn);
	// 		var br = document.createElement('br');
	// 		document.getElementById("documentContainer").appendChild(br);
	// 		//  createCitations("documentContainer", d);
	// 		// container.innerHTML += '\n<p>'+bibs_list+'</p>';
	// 		// add all divs with document information to container
	// 		for(let i=0; i< document_array.length; i++){
	// 			var temp = document_array[i]['childNodes'][2];
	// 			//console.log(document_array[i]);
	// 			temp.addEventListener('click', function(){
	// 				const el = document.createElement('textarea');
	// 					el.value = citation_dict[this.className];
	// 					el.setAttribute('readonly', '');
	// 					el.style.position = 'absolute';
	// 					el.style.left = '-9999px';
	// 					document.body.appendChild(el);
	// 					el.select();
	// 					document.execCommand('copy');
	// 					document.body.removeChild(el);
	// 					alert('Citation has been copied to clipboard')
	// 			})
	// 			container.appendChild(document_array[i]);
	// 		}
	// 		//console.log(citation_dict);
	// 		// button to copy all citations
	// 		document.getElementById("citationButton").onclick = function () {
	// 			//console.log('copy');
	// 			document.execCommand('copy');
	// 			var bibs_length = d.members.length;
	// 			var citations = '';
	// 			for (var j=0; j<bibs_length; j++){
	// 				var authors = d.bibs[j].author;
	// 				var author_list = [];
	// 				for(let i = 0; i<authors.length; i++){
	// 					let author = authors[i].split(" ");
	// 					author = author[author.length-1] + "," + " " + author[0]
	// 					//console.log(author);
	// 					author_list.push(author);
	// 				}
	// 				authors = author_list.join(" and ");
	// 				var first_name = '';
	// 				if (authors.length !== 0){
	// 					var first_name = authors[0].split(" ")[authors[0].split(" ").length-1].toLowerCase();
	// 				}
	// 				var title = d.bibs[j].title;
    //       console.log(d.bibs[j].abstract)
	// 				var title_first_word = title.split(" ")[0].toLowerCase();
	// 				var journal = d.bibs[j].journal;
	// 				var year = d.bibs[j].pubyear.slice(0,-2);
	// 				var volume = d.bibs[j].volume;
	// 				if(first_name == ''){
	// 					var string1 = `@article{${first_name}${year}${title_first_word},\n  title={${title}},\n  journal={${journal}},\n  year={${year}}}`;
	// 				}
	// 				else{
	// 				var string1 = `@article{${first_name}${year}${title_first_word},\n  title={${title}},\n  author={${authors}},\n  journal={${journal}},\n  year={${year}}}`;

	// 				}
	// 				string1 += "\n\n";
	// 				citations += string1;
	// 				const el = document.createElement('textarea');
	// 				el.value = citations;
	// 				el.setAttribute('readonly', '');
	// 				el.style.position = 'absolute';
	// 				el.style.left = '-9999px';
	// 				document.body.appendChild(el);
	// 				el.select();
	// 				document.execCommand('copy');
	// 				document.body.removeChild(el);
	// 			}
	// 			alert('Citations have been copied to clipboard')
	// 		}

	// 	}
	// 	// display mesh terms for current cluster
	// 	//const meshTerms = {{session['id2meshTerms']|tojson}}
	// 	//const meshTermString = meshTerms[d.id]
	// 	//document.getElementById("documentContainer").innerHTML += `<p style="color:black;opacity:0.75">${meshTermString}</p>`;
	// 	}


		function mouseout(d){

			//decide the id of current object (tab or circle)
			if (d.id == undefined){
				id = this.id.slice(-1)
			} else {
				id = d.id;
			}
			//  d3.selectAll('circle').each(function(d){
			// if (d.id == id){
			// 	this.style.stroke = "none"}
			// });
		d3.selectAll(".contextMenu_tooltip_rect").remove();
		d3.selectAll(".contextMenu_tooltip_text").remove();
		d3.selectAll(".contextMenu__documents").remove();
		}


	function hideEdges(d){

		//disable tooltip
		//tooltip.style("visibility", "hidden")

		//decide the id of current object (tab or circle)
		if (d.id == undefined){
			id = this.id;
		} else {
			id = d.id;
		}

		d3.selectAll('circle').each(function(d){

				//if the current circle is not selected, delete the content from panel and cancel the boarder
				if (d.id == id){

					var cluster_id = d.id;

					d3.selectAll('line').each(function(){ //check all lines
						if ($(this).attr("class") == cluster_id){ //if the id of the line is equal to the id of the circle
							// remove network edges
							this.remove();
							//d3.selectAll("#edgeLabel").remove()
						}
					})

					d3.selectAll("."+"edgeLabel"+cluster_id).remove();
				}
		});
	}

	// The table generation function
	function tabulate(data, columns) {
			 var table = d3.select("body").append("table")
							 .attr("id","heuristicTable")
							 .attr("style", "margin-top:45%; z-index:99; position: absolute")
							 .style("visibility","hidden")
							 .style("border-collapse", "collapse")// <= Add this line in
							 .style("border", "2px #4c6d92 solid"), // <= Add this line in
					 thead = table.append("thead"),
					 tbody = table.append("tbody");

			 // append the header row
			 thead.append("tr")
					 .selectAll("th")
					 .data(columns)
					 .enter()
					 .append("th")
					 .attr("style", "font-family: Courier; color: #4c6d92; font-size: 11") // sets the font style
					 .text(function(column) { return column; });

			 // create a row for each object in the data
			 var rows = tbody.selectAll("tr")
					 .data(data)
					 .enter()
					 .append("tr");

			 // create a cell in each row for each column
			 var cells = rows.selectAll("td")
					 .data(function(row) {
							 return columns.map(function(column) {
									 return {column: column, value: row[column]};
							 });
					 })
					 .enter()
					 .append("td")
					 .attr("style", "font-family: Courier; color: #4c6d92; font-size: 11") // sets the font style
					 .html(function(d) { return d.value; });

			 return table;
	 }

	//var width = 1.0*document.getElementById("cluster").offsetWidth;
	//var height = document.getElementById("cluster").offsetHeight;

	function closeMenuAndDocs() {
 		doc_open = false;
 		d3.select('.context-menu').remove();
 		d3.select('foreignObject').remove();
	}
	function contextMenu() {
			 var height = 22,
					 width = 110,
					 margin = 0.1, // fraction of width
					 items = [],
					 rescale = false;

	 function menu(x1, x2, y, circleId) {
			 		closeMenuAndDocs();
				 //  scaleItems();

					 // Draw the menu
			 		//console.log(circleId);
			 		d3.select('#g_'+circleId).raise();
			 		//d3.selectAll('#text_'+circleId).raise();
					 var g = d3.select('#g_'+circleId);
			 		var svg2 = g.insert("svg", "#circle_" + circleId);
							 svg2.append('g').attr('class', 'context-menu')
							 .selectAll('tmp')
							 .data(items).enter()
							 .append('g').attr('class', 'menu-entry')
							 .attr('style','cursor: pointer')
							 .on('mouseover', function(){
									 d3.select(this).select('rect').attr('style', 'fill: rgb(200,200,200)') })
							 .on('mouseout', function(){
									 d3.select(this).select('rect').attr('style', 'fill: rgb(244,244,244); stroke: white; stroke-width: 1px') })
							 .on('click', function(d, i){
								 if (i == 1){
									 var text_id = "menu-text" + i.toString();
									 var menu_text = document.getElementById(text_id).textContent;
									 if (menu_text == 'Show Documents'){
										doc_open = true;
										var data = d3.select('#circle_'+circleId).datum();
										 var foreign = d3.select('svg').append("foreignObject")
												.attr("id", "contextMenu_documents")
												.attr("class", "contextMenu_documents")
												.attr("x", function(){
													var svgWidth = document.getElementById("cluster").offsetWidth;
													if(x2+110+300 > svgWidth){
														return x2-301;
													}else{
														return x2+110;
													}
												})
												.attr("y", function(d, i){
													var svgHeight = document.getElementById("cluster").offsetHeight;
													if((y + (i * height) + 550) > svgHeight){
														// prevent document panel from hitting the bottom or the query info footer
														var diff = (y + (i * height) + 550) - svgHeight;
														return y + (i * height) - diff;
													}else{
														return (y + (i * height));
													}
												})
												.attr("width", 300)
												.attr("height", 400)
												.style("background-color", "#4c6d92")
												.style("border", "solid")
												.style("border-color", "lightgrey")
												.style("padding", "5px")
												.style("font-size", "13px")
												.style("text-align", "left")
												.append("xhtml:div")
												.attr("id", "documentContainer")
												.attr("class", "documentContainer")
												.style("max-height", "400px")
												.style("overflow-y", "scroll");

										 /*var innerSvg = foreign.append("svg")
												.attr("id", "documentSvg")
												.attr("class", "documentSvg")
												.attr("width", 300)
												.attr("height", 1000)
												.style("background-color", "lightgrey")
												.style("opacity", "50%");
										 */
										 document.getElementById(text_id).textContent = 'Hide Documents';
										 console.log("SHOW DOCUMENTS",data);
										 showDocuments(data);
								 	}else{
										doc_open = false;
								 	    document.getElementById(text_id).textContent = 'Show Documents';
								 	    d3.select('foreignObject').remove();
								 	}
								 }else if(i == 2){ // show or hide edges of one cluster
										var text_id = "menu-text" + i.toString();
										var menu_text = document.getElementById(text_id).textContent;
										if (!opened_edges_id.has(circleId)) {

											d3.selectAll('circle').each(function(d){
												if (d.id == circleId){
													showEdges(d);
												}
											})
											document.getElementById(text_id).textContent = 'Hide Edges';
											opened_edges_id.add(circleId);
										} else {
											hideEdges(d);
											document.getElementById(text_id).textContent = 'Show Edges';
											opened_edges_id.delete(circleId);
										}
								 }else if(i == 3){ // hide all edges
									 d3.selectAll('line').remove();
									 for (i=0; i<10; i++){
										 d3.selectAll('.edgeLabel'+i.toString()).remove();
									 }
									 document.getElementById("menu-text1").textContent = 'Show Edges';
									 opened_edges_id.clear();
								 }else if(i == 4){
									 var text_id = "menu-text" + i.toString();
									 var menu_text = document.getElementById(text_id).textContent;
									 if(menu_text == "Zoom in"){
										 document.getElementById('calculate').click();
										 userRelevant.push('Zoom In')
									 }else if(menu_text == "Zoom out"){
										 document.getElementById('back').click();
									 }else{
			 							 closeMenuAndDocs();
									 }
								 }else if (i == 5){
									 var text_id = "menu-text" + i.toString();
									 var menu_text = document.getElementById(text_id).textContent;
									 if(menu_text == "Zoom in"){
										 document.getElementById('calculate').click();
										 userRelevant.push('Zoom In')
									 }else if(menu_text == "Zoom out"){
										 document.getElementById('back').click();
									 }
									 else if(menu_text == "Copy"){
										d3.selectAll('circle').each(function(d){
												if (d.id == circleId){
													copyCitations(d);
												}
											})
									 }
									 else{
			 							 closeMenuAndDocs();
									 }
								 }else if (i == 6){
									var text_id = "menu-text" + i.toString();
									var menu_text = document.getElementById(text_id).textContent;
									 if (menu_text == "Copy"){
										d3.selectAll('circle').each(function(d){
												if (d.id == circleId){
													copyCitations(d);
												}
											})
									 }
			 						 closeMenuAndDocs();
								 }
								 });

			 		 const menu_back_margin_length = 50;
			 		 const menu_text_forward_padding_length = 10;
					 d3.selectAll('.menu-entry')
							 .append('rect')
							 .attr('id', function(d, i){return 'menu-rect' + i.toString()})
							 .attr('class','menu-rect')
							 .attr('x', x1)
                             .attr('y', function(d, i){
                                var svgHeight = document.getElementById("cluster").offsetHeight;
                                if((y + (items.length * height) + 125) > svgHeight){
                                    // prevent menu from hitting the bottom or the query info footer
                                    return (y + (i * height) - items.length * height);
                                }else{
                                    return (y + (i * height));
                                }
                              })
							 .attr('width', 0)
							 .attr('height', height)
							 .attr('style','fill: rgb(244,244,244); stroke: white; stroke-width: 3px; padding:1px;')
							.transition()
							.attr("x", x2 - 50)
                             .attr('y', function(d, i){
                                var svgHeight = document.getElementById("cluster").offsetHeight;
                                if((y + (items.length * height) + 125) > svgHeight){
                                    // prevent menu from hitting the bottom or the query info footer
                                    return (y + (i * height) - items.length * height);
                                }else{
                                    return (y + (i * height));
                                }
                              })
							 .attr('width', width + menu_back_margin_length + menu_text_forward_padding_length)
							 .attr('height', height)
							.duration(500);


					 d3.selectAll('.menu-entry')
							 .append('text')
							 .attr('id', function(d, i){return 'menu-text' + i.toString()})
							 .attr('class','menu-text')
							 .text(function(d){ return d; })
							 .attr('x', x1)
                             .attr('y', function(d, i){
                                var svgHeight = document.getElementById("cluster").offsetHeight;
                                if((y + (items.length * height) + 125) > svgHeight){
                                    // prevent menu from hitting the bottom or the query info footer
                                    return (y + (i * height) - items.length * height);
                                }else{
                                    return (y + (i * height));
                                }
                              })
							 .attr('dy', height - margin / 2 - 2)
							 .attr('dx', margin)
							 .attr('style', 'fill: #4c6d92; font-size: 13')
							.transition()
							.attr("x", x2 + menu_text_forward_padding_length)
                             .attr('y', function(d, i){
                                var svgHeight = document.getElementById("cluster").offsetHeight;
                                if((y + (items.length * height) + 125) > svgHeight){
                                    // prevent menu from hitting the bottom or the query info footer
                                    return (y + (i * height) - items.length * height);
                                }else{
                                    return (y + (i * height));
                                }
                              })
							.duration(500);

						//Other interactions
					 d3.select('#background_rect')
							 .on('mouseover', function() {
									if (!doc_open) { // when documents panel is open, only close the menu when clicking on white background
										opened_id = undefined;
										// menu retreat animation
					 					d3.selectAll('.menu-rect')
										 .transition()
							 			 .attr('x', x1)
                             			 .attr('y', function(d, i){
                             			    var svgHeight = document.getElementById("cluster").offsetHeight;
                             			    if((y + (items.length * height) + 125) > svgHeight){
                             			        // prevent menu from hitting the bottom or the query info footer
                             			        return (y + (i * height) - items.length * height);
                             			    }else{
                             			        return (y + (i * height));
                             			    }
                             			  })
							 			.attr('width', 0)
							 			.attr('height', height)
										.duration(500);
										 console.log('mouseover');

					 					d3.selectAll('.menu-text')
										 .transition()
							 			 .text('')
							 			 .attr('x', x1)
                             			 .attr('y', function(d, i){
                             			    var svgHeight = document.getElementById("cluster").offsetHeight;
                             			    if((y + (items.length * height) + 125) > svgHeight){
                             			        // prevent menu from hitting the bottom or the query info footer
                             			        return (y + (i * height) - items.length * height);
                             			    }else{
                             			        return (y + (i * height));
                             			    }
                             			  })
							 			.attr('width', 0)
							 			.attr('height', height)
										.duration(500);
									}
							 })
							 .on('click', function() {
									opened_id = undefined;
									closeMenuAndDocs();
							 });

			 }


				 menu.items = function(e) {
						 if (!arguments.length) return items;
						 for (i in arguments) items.push(arguments[i]);
						 rescale = true;
						 return menu;
				 }





			 return menu;
	 }

			function textualize (d) {

				var selection = d3.select(this);
				selection.text(function (d) {
						return d.keyword.term;
				})
				.attr("id", function(d){return('text_'+d.id)})
				.style('-webkit-user-select', 'none')
				.style('-khtml-user-select', 'none')
				.style('-moz-user-select', 'none')
				.style('-ms-user-select', 'none')
				.style('-o-user-select', 'none')
				.style('user-select', 'none')
				.attr("font-family", "sans-serif")
				.attr("font-size", function (d) {
						return d.font_scale * 3;
				})
				.attr("fill", function(d){
						if (entity == 'authors' || (dataset_opt == 'Experts' && entity == 'experts')) {
							return color_code_table[d.keyword['color_code']];
						} else {
							return 'white';
						}
				})
				.attr('pointer-events', 'none')
				.attr("text-anchor", "middle")
				.attr("text-transform", "capitalize")
				.attr("x",600)
				.attr("y",function(d){
						return (d.y-300)/600*100+300;
				})
				//.on('mouseover', function(d){d3.event.preventDefault(); mouseover(d, d.min_resize_factor); })
				//.on('mousemove', function(){return (tooltip.style("top", (event.pageY-10)+"px").style("left",(event.pageX+10)+"px"));})
				//.on('mouseout', mouseout)

				//.on('contextmenu', function(d){
				//	const selected_bibs = current_selection_trace.current_selected_bibs;
				//	if(selected_bibs.size>=zoom_in_threshold){
				//		if(current_selection_trace.level > 0) {
				//			var menu = contextMenu().items('Show Documents', 'Show Edges', 'Hide All Edges', 'Zoom in', 'Zoom out', 'Close Menu');
				//		} else {
				//			var menu = contextMenu().items('Show Documents', 'Show Edges', 'Hide All Edges', 'Zoom in', 'Close Menu');
				//		}
				//	}else{
				//		if(current_selection_trace.level > 0) {
				//			var menu = contextMenu().items('Show Documents', 'Show Edges', 'Hide All Edges', 'Zoom out', 'Close Menu');
				//		} else {
				//			var menu = contextMenu().items('Show Documents', 'Show Edges', 'Hide All Edges', 'Close Menu');
				//		}
				//	}
				//	d3.event.preventDefault();
				//	//menu(d['clientX']-1, d['clientY']-61, textLabels['_groups'][0][i].id);
				//	console.log(d.optimized_cx);
				//	console.log(d.optimized_cy);
				//	console.log(d.min_resize_factor);
				//	menu(d.optimized_cx, d.optimized_cx + d.actual_radius * d.min_resize_factor, d.optimized_cy - 0.5 * d.actual_radius * d.min_resize_factor, d.id);
				//})
				.transition()
				.attr("x", function (d) {
						return d.x;
				})
				.attr("y", function (d) {
						// draw the first name and last name of long author names together as a visual cue that these two labels belong to one person
                        if (d.keyword.flag == 'first_part') {
                            return d.y + 0.3 * d.font_scale;
                        } else if (d.keyword.flag == 'last_part') {
                            return d.y - 0.3 * d.font_scale;
                        } else { // non-broken full name
                            return d.y;
                        }
				})
				.duration(500);
			};

			function calc_mean_and_stddev(arr){
			  const mean = arr.reduce((acc, val) => acc + val, 0) / arr.length;
			  const stddev = Math.sqrt(
			    arr.reduce((acc, val) => acc.concat((val - mean) ** 2), []).reduce((acc, val) => acc + val, 0) /
			      (arr.length)
			  );
			  return {"mean": mean, "stddev": stddev};
			};



</script>

<script type=text/javascript charset="utf-8">
	$SCRIPT_ROOT = {{ request.script_root|tojson|safe }};
</script>

<!--style for bubble chart-->
<style>
	#tabs .ui-state-active {
		background: #45a049 !important;
		border: 0px solid #fff;
	}

	circle {
		stroke-width: 3px;
	}
</style>

<!-- commented out as it's probably not needed
<style>
 .bubbleChart {
		 min-width: 100px;
		 max-width: 900px;
		 height: 600px;
		 margin: 0;
 }
</style>
-->

<script type=text/javascript charset="utf-8">
 window.onload = function() {
 // declare global variable
 var width = 1.0*document.getElementById("cluster").offsetWidth;
 var height = document.getElementById("cluster").offsetHeight;
//console.log(width)

	$(function() {
		<!-- bydate -->
		$('a#bydate').bind('click', function() {
			//console.log("dataset: " + dataset)
			var list_bydate = []
			var latest_year = ''
			var oldest_year = ''
			var object_bydate = {};
			var all_ranges = []
			//console.log(dataset)
			//grabing all data
			d3.selectAll('circle').each(function(d){
				//console.log("circle data is: ")
				//console.log(d)
				//console.log(d.bibs)
				for (bib_ind in d.bibs){
					//console.log(d.bibs[bib_ind])
					//find out the date range; assume the list is not ranked by date
					var date = d.bibs[bib_ind].pdate
					if (latest_year == '' || latest_year < date.substring(0,4)){
						latest_year = date.substring(0,4)
					}
					if (oldest_year == '' || oldest_year > date.substring(0,4)){
						oldest_year = date.substring(0,4)
					}
					list_bydate.push(d.bibs[bib_ind])
				}
			});
				//console.log("latest_year is:")
				//console.log(latest_year)
				//console.log("oldest_year is:")
				//console.log(oldest_year)
				var date_range = Number(latest_year) - Number(oldest_year);
				//set the number of intervals.
				if (date_range == 0){ //if there are one year presents, do monthly
					var number_of_intervals = 12
					var current_year = latest_year
					for (var i = 1; i <= number_of_intervals; i++){ //getting all date intervals
						if (i<10){
							var current_month = '0'+ i.toString()
						} else {
							var current_month = i.toString()
						}
						var current_range_str = current_year + '-' + current_month
						//console.log("current_range_str: " + current_range_str)
						object_bydate[current_range_str]=[]
						all_ranges.push(i)
					}

					for (var i in list_bydate){
						//console.log(list_bydate[i])
						var date = list_bydate[i].pdate
						var doc_month = date.substring(0,7)
						//console.log("doc_month: " + doc_month)
						object_bydate[doc_month].push(list_bydate[i])
					}

				} else if (date_range > 10){ //if there are more than 10 years present, count the years older than 10 years together.
					var number_of_intervals = 11
					var current_year = latest_year
					var final_range = ''
					for (var i = 0; i < number_of_intervals; i++){ //getting all date intervals
						if(i != 10){
							var current_range_str = current_year - i
						} else {
							var current_range_str = oldest_year + '-' + (current_year - i)
							final_range = current_range_str
						}
						//console.log("current_range_str: " + current_range_str)
						object_bydate[current_range_str]=[]
						all_ranges.push()
					}

					for (var i in list_bydate){
						//console.log(list_bydate[i])
						var date = list_bydate[i].pdate
						var doc_year = date.substring(0,4)
						//console.log("doc_year: " + doc_year)
						if (object_bydate[doc_year]) {
							object_bydate[doc_year].push(list_bydate[i])
						} else {
							object_bydate[final_range].push(list_bydate[i])
						}

					}

				} else { //if there are more than one year but less than 10 years present, do yearly.
					var number_of_intervals = date_range + 1;
					var current_year = latest_year
					for (var i = 0; i < number_of_intervals; i++){ //getting all date intervals
						var current_range_str = current_year - i
					}
						//console.log("current_range_str: " + current_range_str)
						object_bydate[current_range_str]=[]
						all_ranges.push()
					}

					for (var i in list_bydate){
						//console.log(list_bydate[i])
						var date = list_bydate[i].pdate
						var doc_year = date.substring(0,4)
						//console.log("doc_year: " + doc_year)
					}

				//console.log("number_of_intervals")
				//console.log(number_of_intervals)
				//console.log(object_bydate)
			//console.log(all_ranges)
	})
});


	function zoomIn() {
		//console.log("reclustering width: " + width)

		d3.select('.context-menu').remove();
		d3.select('foreignObject').remove();
		// remove all bubble covers to stop receiving pointer events
		d3.selectAll('.cover').remove();
		//reclustering the documents in selected bubbles
		var check = 0;
		d3.selectAll(".bubble").each(function(){
			if (this.style.filter != "url(\"#grayscale\")") {
				check += 1;
				//remove all the tabs for documents
				var cluster_id = this.id;
			}
		});
		if (check > 0){
			$('input[name="ids"]').prop('checked', false);

			var all_texts = d3.selectAll("text");
			var all_circles = d3.selectAll(".bubble");
			//  .attr("fill",red);
			var all_circles_data = d3.selectAll(".bubble").data();
			//console.log("cir_data="+all_circles_data )
			var ids = [] ;
			var arrayLength = all_circles["_groups"][0].length;

			for ( var i = 0 ; i <arrayLength ; i++) {

				 if (all_circles["_groups"][0][i].style.filter != "url(\"#grayscale\")") {
					//if (all_circles["_groups"][0][i].style.filter =="url('#f1')" ){
					 //console.log( all_circles.data()[i].item.id.toString()+ " is selected.")
					 ids.push(all_circles_data[i].id)
					//animation of gathering
					//choosing circle by its id
					//moving the texts with circle when the distance between their coordiniation and the circle center are less than r
					var this_circle = all_circles["_groups"][0][i]
					var circle_x = this_circle.getAttribute("cx")
					var circle_y = this_circle.getAttribute("cy")
					var circle_r = this_circle.getAttribute("r")
					var circle_id = this_circle.getAttribute("id").split('_')[1]
					var selected_circle = d3.select(this_circle);
					selected_circle
						.transition()
						.attr("cx",600)
						.attr("cy",300)
						// .delay()
						.duration(500);
					d3.selectAll("text").each(function(){
						var text_id = this.getAttribute("id").split('_')[1];
						var text_x = this.getAttribute("x");
						var text_y = this.getAttribute("y");
						//console.log(text_x)
						//console.log(text_y)
						//console.log(circle_x)
						//console.log(circle_y)
						if (text_id == circle_id){
							var selected_text = d3.select(this);
							selected_text
								.transition()
								.attr("x",600)
								.attr("y",300 + (text_y-circle_y))
								// .delay()
								.duration(500);
								}
							});
						//}
						 }else{
							var this_circle = all_circles["_groups"][0][i];
							var selected_circle = d3.select(this_circle);
							var circle_id = this_circle.getAttribute("id").split('_')[1]
							selected_circle.remove();
							d3.selectAll("text").each(function(){
								var text_id = this.getAttribute("id").split('_')[1];
								//console.log(text_x)
								//console.log(text_y)
								//console.log(circle_x)
								//console.log(circle_y)
								if (text_id == circle_id){
									var selected_text = d3.select(this);
									selected_text
										.remove()
										}
									});
						}
//    		 if (all_circles[i].style.stroke == "gray") {
//    			alert( all_circles[i].item.id.toString()+ " is selected.")
				}
				count_documents = 0
				for (var i = 0; i < ids.length; i++) {
						count_documents += all_circles_data[ids[i]].count
				}



			 //remove the edges
			d3.selectAll("line").remove();

			var sessionData = JSON.parse(sessionStorage.getItem('sessionData'));
			var sessionState = sessionData.state;
			sessionData['ids_'+sessionState] = ids;
			sessionStorage.setItem('sessionData', JSON.stringify(sessionData));
		 	turnOnLoadingPrompt();
			 setTimeout(//delay the following code for 1000ms such that the animation can be finished
				renderNewClusters
			 ,1900);//end of setTimeout
			 return false;
			}else{
				alert( "No cluster has been selected.")
			}
	}
	document.getElementById("zoom-in-button").addEventListener('click', zoomIn);
  //document.getElementById('entities_menu').style.opacity= 0

	$(function() {
		<!-- reclustering -->
		$('a#calculate').bind('click', zoomIn);
	});

	function zoomOut() {
		//console.log("back width: " + width)
		// console.log("Going to zoom out");
		var check = 0;
		d3.selectAll(".bubble").each(function(){
			if (this.style.filter != "url(\"#grayscale\")") {
				check += 1;
				//remove all the tabs for documents
				var cluster_id = this.id;
			}
		});
		// unselect all check boxes
		$('input[name="ids"]').prop('checked', false);

		const sessionData = JSON.parse(sessionStorage.getItem('sessionData'));
		var state = sessionData['state'];
		var stage_alert = "";
		var ids;
		if (state == 0) {
    	    state = state + 1
    	    ids = sessionData["chosen_0"]
		} else if (state == 1) {
    	    ids = sessionData['chosen_0']
		} else {
    	    ids = sessionData['chosen_' + String(state-1)]
		}
      	const id2members = sessionData['id2members_'+String(state-1)];
		const id2freq = {};
		for (const id in id2members) {
			id2freq[id] = id2members[id].length;
		}

    	const chosen = [];
		for (const i in id2members) {
    	    if (ids.includes(String(i))) {
    	        chosen.push(1);
			} else {
    	        chosen.push(0);
			}
		}
		var val = [];
		for (const i in id2freq.length) {
			val.push(0.6);
		}

		/* roll back session data and clean up the previous level */
		sessionData['state'] = state - 1
		sessionData['id2members_'+String(state)] = undefined;
		sessionData['cluster_desc_'+String(state)] = undefined;
		sessionData['cluster_summary_'+String(state)] = undefined;
		sessionData['xy_'+String(state)] = undefined;
		sessionData['hue_'+String(state)] = undefined;
		sessionData['satr_'+String(state)] = undefined;
		sessionData['edges_'+String(state)] = undefined;
		sessionData['org_ids_'+String(state)] = undefined;

     	var cls = { 'id2freq': id2freq,
				'desc': sessionData['cluster_desc_'+String(state-1)],
				'summary': sessionData['cluster_summary_'+String(state-1)],
      	        'xy': sessionData['xy_'+String(state-1)],
      	        'hue': sessionData['hue_'+String(state-1)],
      	        'satr': sessionData['satr_'+String(state-1)],
      	        'val': val,
      	        'id2members': id2members,
      	        'chosen': chosen,
				'edges': sessionData['edges_'+String(state-1)]
			};
		var data = {'cls': cls};

		sessionStorage.setItem('sessionData', JSON.stringify(sessionData))
		var new_data = generateNewData(data);
		const current_level = current_selection_trace.decreaseLevel();
		// console.log("Data to be zoomed out: " + JSON.stringify(new_data));
		rerenderClusters(new_data, current_level);
		d3.selectAll(".cover").each(function(d){
			if (d.chosen == 1){
				//console.log("choose this circle")
				d3.selectAll('#circle_' + d.id).each(choose_bubbles,d);
			}

		})



	}

	document.getElementById("zoom-out-button").addEventListener('click', zoomOut);
<!-- back -->
$(function() {
	<!-- reclustering -->
	$('a#back').bind('click', zoomOut);
}); //end of back function

	function renderNewClusters() {
		 $.post($SCRIPT_ROOT + '/_re_cluster', {
			 sessionData: sessionStorage.getItem('sessionData')
		 }).done(function(data) {
			//  console.log("Entering renderNewClusters");
			 let oldSessionData = sessionStorage.getItem('sessionData');
			 //console.log(JSON.parse(oldSessionData))

			 let newSessionData = data.newSessionData;
			 //console.log(data)
			 //console.log(newSessionData);
			 // Console log the old session data
			//  console.log("oldSessionData: " + oldSessionData);
			//  console.log("oldSessionData.state: " + JSON.parse(oldSessionData).state);
			 // Console log the new session data
			//  console.log("newSessionData: " + newSessionData);
			 // New session data has [object object] as its value, so we need to parse it to see the actual data
			//  console.log("newSessionData: " + JSON.stringify(newSessionData));
			 
			//  console.log("newSessionData.state: " + newSessionData.state);
			// display id2members for each state it is of the form id2members_0, id2members_1, id2members_2, etc till the last state
			for (var i = 0; i <= newSessionData.state; i++) {	
				// console.log("newSessionData.id2members_" + i + ": " + newSessionData["id2members_" + i]);	
				// console.log("newSessionData.cluster_desc_" + i + ": " + newSessionData["cluster_desc_" + i]);
				// console.log("newSessionData.cluster_summary_" + i + ": " + newSessionData["cluster_summary_" + i]);
				// console.log("newSessionData.xy_" + i + ": " + newSessionData["xy_" + i]);
				// console.log("newSessionData.hue_" + i + ": " + newSessionData["hue_" + i]);
				// console.log("newSessionData.satr_" + i + ": " + newSessionData["satr_" + i]);
				// console.log("newSessionData.edges_" + i + ": " + newSessionData["edges_" + i]);
				
			}	
			 /* update session storage with updated data */
			 sessionStorage.setItem('sessionData', JSON.stringify(newSessionData));
			 //formatting the new data
			 let new_data = generateNewData(data);
			 // Print the new data and current level
			//  console.log("new data: " + new_data);
			//  console.log("current level: " + current_selection_trace.level);
			 // Print that the data is ready
			//  console.log("Data is ready");
			 const current_level = current_selection_trace.increaseLevel();
			 rerenderClusters(new_data, current_level);

			document.getElementById("zoom-in-button").style.display = 'none'; // hide zoom in button after entering the next reclustering space
		 	turnOffLoadingPrompt();
		}).fail( function(xhr, textStatus, errorThrown) {
           alert("Sorry, there is not enough information to cluster");
           location.reload()
        });;

	}

	// "desc":[[["Trump's","Election","Focus"]],[["Trump's","Legal","Battles"]],[["Debate","Highlights"]],[["Trump","Assassination","Attempts"]],[["Trump's","False","Claims"]],[["Trump","vs.","Endorsements"]],[["Trump","Rally","Security","Concerns"]],[["Trump","vs.","Harris","Debate"]],[["RFK","Jr.","Endorses","Trump"]],[["Late","Night","News"]]],"summary":[["Trump, Vance, and election concerns."],["Various legal issues involving Trump."],["Trump-Harris debate key takeaways and moments."],["Attempted attacks on Trump prompt Secret Service scrutiny."],["News about Trump's misleading statements and their repercussions."],["Political endorsements and controversies among Trump, RFK Jr., and Taylor Swift."],["Various news on Secret Service failures and rally incidents."],["Coverage on election debate dynamics."],["Robert F. Kennedy Jr. suspends campaign to endorse Trump."],["Late night shows' takes on debates, Trump, Musk, and Biden."]],

	// "desc":{"0":["Trump","Legal","Battles"],"1":["RFK","Jr","vs.","Trump","in","North","Carolina"],"2":["RFK","Jr","Endorses","Trump"],"3":["Political","Maneuverings"],"4":["Trump's","Election","Prospects"],"5":["Kamala","Harris","Campaign","Focus"],"6":["US","Election","Updates"],"7":["Republican","Strategies","on","Women","Voters"],"8":["Election","Contingency","Planning"],"9":["Trump's","Expensive","Tax","Cuts"]},

	function generateNewData(data) {
	 	var new_data = [] ;
		data_length = data.cls.desc.length ;
		// console.log("generateNewData data: " + JSON.stringify(data));
		// Get the data_length
		// console.log("generateNewData data_length: " + data_length);
		

		for (var i = 0 ; i < data_length ; i++ ) {
		    temp_obj = {};
		    keywords = [];
		    word_length = data.cls.desc[i].length ;
		    for (var j = 0 ; j < word_length ; j++) {
		   		 keywords.push(data.cls.desc[i][j]);
		    }

		    temp_obj["keywords"]= keywords;
		    temp_obj["edges"] = data.cls.edges;
		    //console.log("keywords = "+keywords)
		    temp_obj["count"] = data.cls.id2freq[i];
		    temp_obj["id"] = i.toString();
		    //console.log(i + "and" + temp_obj["id"])
		    temp_obj["cx"] = data.cls.xy[i][0];
		    temp_obj["cy"] = data.cls.xy[i][1];
		    temp_obj["hue"] = data.cls.hue[i];
		    temp_obj["satr"] = data.cls.satr[i];
		    temp_obj["val"] = data.cls.val[i];
		    var members = data.cls.id2members[i];
		    temp_obj["members"] = members;
		    //console.log("id2members="+members);
		    new_data.push(temp_obj);
		}

		return new_data;
	}

	function rerenderClusters(new_data, current_level) {
		// Print which function is running
		// console.log("reclustering ----> rerenderClusters is running");
		// console.log("current level: " + current_level);

		// console.log("new data: "+new_data);
		//remove the old svg
		 d3.select("svg").remove();

		 //add heutistic table
		var heuristicTable = tabulate([{'Distance':'Very Similar','Meaning':'More than or equal to 75% semantic similarity'}, {'Distance':'Similar','Meaning':'Between 50% and 75% semantic similarity'},{'Distance':'Distant', 'Meaning':'Less than 50% semantic similarity'}], ["Distance", "Meaning"]);

		heuristicTable.selectAll("tbody tr")
					.sort(function(a, b) {
									return d3.descending(a.close, b.close);
					});

		heuristicTable.selectAll("thead th")
					.text(function(column) {
									return column.charAt(0).toUpperCase()+column.substr(1);
					});

		var svg = d3.select(".bubbleChart")
						.append("svg")
						.attr("width",width)
						.attr("height",height)

		var rect = d3.select('svg').append("rect")
					 .attr("id","background_rect")
					 .attr("fill","white")
					 .attr("height",height)
					 .attr("width", width);

		var dataset =  new_data;

	  	let count_list = dataset.map(data => data.count);
	  	let mean_and_stddev = calc_mean_and_stddev(count_list);
	  	let count_mean = mean_and_stddev["mean"];
	  	let count_stddev = mean_and_stddev["stddev"];

		// Print all the above information
		// console.log("count_list: " + count_list);
		// console.log("mean_and_stddev: " + mean_and_stddev);
		// console.log("count_mean: " + count_mean);
		// console.log("count_stddev: " + count_stddev);
		// Print bubble chart data
		// console.log("svg: " + svg);
		// console.log("dataset: " + dataset);

	  	for (let data of dataset) {
	  		let diff = count_mean - data.count;
	  		/* clusterSizeScore is the adjusted doc count that reduces the overall standard deviation of doc count of each cluster, which is used to decrease the difference between bubble sizes */
	  		data["cluster_size_score"] = data.count + diff * 0.4 * count_stddev / count_mean;

	  		const half_width = width / 2;
	  		const half_height = height / 2;
	  		let cx = 200 + data["cx"] * 0.75 *(width-200)
	  		/* if cx is less than half of width, draw it closer to x = 0; otherwise, draw it closer to x = width */
	  		data["optimized_cx"] = cx - cx * 0.1 + Math.floor(cx / half_width) * width * 0.1 ;

	  		let cy = 150 + data["cy"] * 0.75 *(height-200)
	  		/* if cy is less than half of height, draw it closer to y = 0; otherwise, draw it closer to y = height */
	  		data["optimized_cy"] = cy - cy * 0.1 + Math.floor(cy / half_height) * height * 0.1 ;

	  		for (var edge of data.edges) {
	  			let edge_x1 = 200 + edge.source[0] * 0.75 *(width-200)
	  			optimized_edge_x1 = edge_x1 - edge_x1 * 0.1 + Math.floor(edge_x1 / half_width) * width * 0.1 ;
	  			let edge_y1 = 150 + edge.source[1] * 0.75 *(height-200)
	  			optimized_edge_y1 = edge_y1 - edge_y1 * 0.1 + Math.floor(edge_y1 / half_height) * height * 0.1 ;
	  			let edge_x2 = 200 + edge.target[0] * 0.75 *(width-200)
	  			optimized_edge_x2 = edge_x2 - edge_x2 * 0.1 + Math.floor(edge_x2 / half_width) * width * 0.1 ;
	  			let edge_y2 = 150 + edge.target[1] * 0.75 *(height-200)
	  			optimized_edge_y2 = edge_y2 - edge_y2 * 0.1 + Math.floor(edge_y2 / half_height) * height * 0.1 ;
	  			edge["optimized_source"] = [optimized_edge_x1, optimized_edge_y1];
	  			edge["optimized_target"] = [optimized_edge_x2, optimized_edge_y2];
	  		}
	  	}

		 var node = svg.selectAll(".node")
			.data(dataset)
			.enter();

		for(let data of dataset){
			let members = data['members'];
			var bibs = {{session['bibs_0']|safe}}
			var bibs_ = {};
			for (var j = 0; j < members.length; j++){
			 var member = members[j];
			 bibs_[j]={};
		   	 bibs_[j]["title"] = bibs[member]['title'];
		   	 bibs_[j]["body_toshow"] = bibs[member]['body_toshow'];
		   	 bibs_[j]["author"] = bibs[member]['author'];
		   	 bibs_[j]["journal"] = bibs[member]['journal'];
		   	 bibs_[j]["pdate"] = bibs[member]['pubdate'];
			 bibs_[j]['pubyear'] = bibs[member]['pubYear'];
			 bibs_[j]['journal_abbrev'] = bibs[member]['journal_abbrev'];
			 bibs_[j]['volume'] = bibs[member]['volume'];
			 bibs_[j]['issue'] = bibs[member]['issue'];
			 bibs_[j]['doi'] = bibs[member]['doi'];
			 bibs_[j]['pages'] = bibs[member]['pages'];
		   	 bibs_[j]["pmid"] = bibs[member]['pmid'];
		   	 bibs_[j]["html"] = bibs[member]['html'];
         bibs_[j]["abstract"] = bibs[member]['abstract'];
			}
			data["bibs"] = bibs_
			//console.log('Dataset');
		}

		const num_documents = dataset.reduce((acc, d) => acc + d.count, 0);

		/* To calculate circle's actual radii */
	  	for (let data of dataset) {
			data["actual_radius"] = Math.sqrt(data["cluster_size_score"]/(num_documents*1.2))*270;
		}

		/* To calculate how much we need to resize the circle's radii to fully exploit available space (when no bubbles overlapping) or prevent overlapping (when there are) */
		var min_resize_factor = Infinity;
		for (var i = 0; i < dataset.length - 1; i++){
			let data_i = dataset[i];
			let actual_radius_i = data_i["actual_radius"];

			/* find the min_resize_factor needed to reach the closest bounding box edge*/
            const cx_i = data_i["optimized_cx"];
            const cy_i = data_i["optimized_cy"];
            const min_dx = Math.min(cx_i, width - cx_i);
            const min_dy = Math.min(cy_i, height - cy_i);
            const min_d = Math.min(min_dx, min_dy);
            let resize_factor = min_d / actual_radius_i - 0.05;
            min_resize_factor = Math.min(resize_factor, min_resize_factor);

			/* iterate through the remaining bubbles to find the min_resize_factor to reach the closest bubble */
			for (var j = i + 1; j < dataset.length; j++){
					let data_j = dataset[j];
					let actual_radius_j = data_j["actual_radius"];
					let sum_radius = actual_radius_i + actual_radius_j;
					let x_diff = data_i["optimized_cx"] - data_j["optimized_cx"];
					let y_diff = data_i["optimized_cy"] - data_j["optimized_cy"];
					let distance = Math.sqrt(x_diff * x_diff + y_diff * y_diff);
					let diff = sum_radius - distance;
					let resize_factor = 1 - diff / sum_radius - 0.05;
					min_resize_factor = Math.min(resize_factor, min_resize_factor);
			}

		}

		var modified_dataset = modify_data(dataset, width, height, min_resize_factor);
		// var modified_dataset = dataset;
    //document.getElementById('entities_menu').style.opacity= 0

		//  var texts = svg.selectAll("text")
		// 	.data(modified_dataset[0])
		// 	.enter()
		// 	.append("text");


		// 	//Add SVG Text Element Attributes
		// 	var textLabels = texts.each(textualize, d);

		 var g = node
				.append("g").attr("id", function(d){return 'g_'+d.id;})


		 //making the new circles
			var circle = g.append("circle")
				.attr("class", "bubble")
				.attr("id", function(d){return( 'circle_' + d.id )})
				//.attr("pulse",false)
				.attr("fill", function(d){
					return (d3.hsl(d.hue, .25, 0.8 ));
				 })
				.attr("style",'filter:url(\"#grayscale\")')
				.attr("cx", 600)
				.attr("cy", 300)
				.attr("r", function(d) { return d.actual_radius * min_resize_factor; })
				.attr('pointer-events', 'none')
				.transition()
				.attr("cx", function(d) { return d.optimized_cx; })
				.attr("cy", function(d) { return d.optimized_cy; })
				.duration(500);

				var texts = svg.selectAll("text")
			.data(modified_dataset[0])
			.enter()
			.append("text");

			var members_dict = {};
			d3.selectAll('circle').each(function(d){
				let id = this.id;
				members_dict[id] = d.members;
			});

			//Add SVG Text Element Attributes
			var textLabels = texts.each(textualize);
			d3.selectAll('text').each(function(d){
				var id = this.getAttribute('id').split('_')[1];
				var g = d3.select('#g_'+id);
				var selection = this;
				g.append(function(){return selection;});
			})

			//adding zoom feature
			// var zoom = d3.zoom()
			// 	// only scale up, e.g. between 1x and 50x
			// 	.scaleExtent([1, 10])
			// 	.on("zoom", function(){
			// 		var e = d3.event;
			// 		tx = Math.min(0, Math.max(e.transform.x, width - width * e.transform.k)),
			// 		ty = Math.min(0, Math.max(e.transform.y, height - height * e.transform.k));
			// 		g.attr('transform', [
			// 				"translate(" + [tx, ty] + ")",
			// 				"scale(" + e.transform.k + ")"
			// 	 ].join(" "));
			// 		texts.attr('transform', [
			// 				"translate(" + [tx, ty] + ")",
			// 				"scale(" + e.transform.k + ")"
			// 	 ].join(" "));
			// 	})
				//svg.call(zoom);

			
			// Method 2

			// // // Adding zoom feature
			// // var baseFontSize = 12;  // Set this to your desired initial font size

			// // // Adding zoom feature
			// // var zoom = d3.zoom()
			// // 	// Only scale up between 1x and 10x
			// // 	.scaleExtent([1, 10])
			// // 	.on("zoom", function(event){
			// // 		var e = d3.event;

			// // 		// Calculate translation limits based on zoom
			// // 		var tx = Math.min(0, Math.max(e.transform.x, width - width * e.transform.k));
			// // 		var ty = Math.min(0, Math.max(e.transform.y, height - height * e.transform.k));

			// // 		// Apply zoom transformation to the bubbles
			// // 		g.attr('transform', "translate(" + tx + "," + ty + ") scale(" + e.transform.k + ")");

			// // 		// Apply only translation to the text (no scaling)
			// // 		texts.attr('transform', "translate(" + tx + "," + ty + ")");

			// // 		// Adjust font size based on zoom level
			// // 		texts.style('font-size', function() {
			// // 			return (baseFontSize / e.transform.k) + "px";  // Inversely scale the font size
			// // 		});
			// // 	});

			// // Set initial text size explicitly
			// texts.style('font-size', baseFontSize + "px");

			// Attach the zoom behavior to the svg
			// d3.select("svg").call(zoom);



			d3.select(self.frameElement)
					.style("height", height + "px");

			var svg = d3.select("svg");
			var defs = svg.append("defs");

			var grayscalefilter = defs.append('svg:filter')
				.attr('id','grayscale');
			grayscalefilter.append('svg:feColorMatrix')
				.attr('type','matrix')
				.attr('values','0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0');

			// transparent circle to receive pointer events
		g.append("circle")
			.attr('class', 'cover')
			.attr("r", function(d) { return d.actual_radius * min_resize_factor; })
			.attr("cx", function(d) { return d.optimized_cx; })
			.attr("cy", function(d) { return d.optimized_cy; })
			.attr("fill", "none")
			.attr('pointer-events', 'all')
			.on('mouseover', function(d){d3.event.preventDefault(); mouseover(d, min_resize_factor); })
			.on('mouseout', mouseout)

			d3.selectAll(".cover").on("click", function(d) {


				d3.selectAll('#circle_'+d.id).each(choose_bubbles,d);
				//$(floater)
			});//end of text click

				//d3.selectAll("circle").on("click",choose_bubbles);



				//$(floater)

	}


//	let search_height = document.getElementById("query").style.height;
//	console.log(search_height);
//	document.getElementById("Explore").style.height=`${search_height}`;
//	document.getElementById("Explore").style.paddingTop='9px';
	var marker = document.querySelector("#marker");
	var items = document.querySelectorAll("nav a");
	//console.log(items);
	//console.log(document.querySelectorAll('input')[0]);


	const regionsButton = document.getElementById('regions');
	const moreButton = document.getElementById('more');
	function moveIndicatorTo(e) {
		if (!e) { return; }
		if (e.id === 'regions-button' || e.id === 'more-button') {
			/* click on 'Regions' or 'More' should not trigger anything, the legal buttons to trigger are in the drop down menu */
			return;
		}
		var dest;
		const containerId = e.parentNode.parentNode.id;
		//console.log(containerId); /* find out the id of the ul that contains this item */
		if (containerId === 'regions-ul') {
			//console.log(regionsButton);
			dest = regionsButton;
		} else if (containerId === 'more-entities-ul') {
			//console.log(moreButton);
			dest = moreButton;
		} else {
			dest = e;
		}
		marker.style.left = dest.offsetLeft-5 + "px";
		marker.style.width = dest.offsetWidth-10 + "px";

	}

	items.forEach(link => {
		link.addEventListener('click', (e) => {
			moveIndicatorTo(e.target);
		})
	})
$(document).ready(function() {

	var inReclusterSpace = false;
	var data = JSON.parse(sessionStorage.getItem('sessionData'));
	const lastQuery = sessionStorage.getItem('currentDecoratedQuery');

	const currentQuery = {{decoratedQuery|tojson}};
	/* if reclustering has been done at least once when the page refreshes, reload the last clustering space instead of start from the beginning */
	if (data && (lastQuery !== undefined || lastQuery !== null)) {
		/* when page refreshes while there is still session data, roll back one step/state to recalculate the clusters for this step */
		var sessionState = data.state;
		if (sessionState > 0 && lastQuery === currentQuery) {
			data['state'] = sessionState - 1;
			sessionStorage.setItem('sessionData', JSON.stringify(data));
			inReclusterSpace = true;
		} else if (sessionState == 0 && lastQuery === currentQuery) {

		} else if (sessionState == 0 && lastQuery !== currentQuery) {
			const sessionData = {{sessionData|tojson|safe}};
			sessionStorage.setItem('sessionData', JSON.stringify(sessionData));
			sessionStorage.setItem('currentDecoratedQuery', currentQuery);

		} else if (sessionState > 0 && lastQuery !== currentQuery) {
			const sessionData = {{sessionData|tojson|safe}};
			sessionStorage.setItem('sessionData', JSON.stringify(sessionData));
			sessionStorage.setItem('currentDecoratedQuery', currentQuery);
		}
		updateCurrentEntity(entity);
	} else {
		/* first time searching */
		const sessionData = {{sessionData|tojson|safe}};
		try {
			sessionStorage.setItem('sessionData', JSON.stringify(sessionData));
		} catch (e) {
			//console.log(e)
			alert("We are sorry but there's some issue processing this file. Please contact us and ask for help. ")
			window.location.assign({{url_for('home')|tojson}})
		}
		sessionStorage.setItem('currentDecoratedQuery', currentQuery);
		/* default entity */
        if (dataset_opt == 'PubMedAPI') {
        	updateCurrentEntity('keywords');
        } else {
            updateCurrentEntity('experts');
        }
	}
	const currentEntity = getCurrentEntity();
	//console.log(currentEntity)
	const entityButton = document.getElementById(currentEntity);
	moveIndicatorTo(entityButton);
	//if(currentEntity !== 'keywords' && currentEntity !== 'genes' && currentEntity !== 'pharmacology' && currentEntity !== 'authors'){
	//	document.getElementById(`${currentEntity}_li`).style.backgroundColor="#ddd";
	//	document.getElementById(`${currentEntity}`).style.color = "black";
	//}

    // configure redirect to cluster url (with args) on clicking search button
    $('#usrform').on('submit', function (e) {
        e.preventDefault();
        var dataset_opt = {{ dataset|tojson }}
		var num_cls = {{num_cls|tojson}}
        window.location.assign({{url_for('cluster')|tojson}}
			+ '?dataset_opt=' + dataset_opt
			+ '&query=' + $('#query-secondary').val()
			+ '&entity=' + currentEntity
			+ '&num_cls=' + num_cls)
    });

	if (inReclusterSpace) {
		renderNewClusters();
		return;
	}
	//console.log("ready width: " + width)
	//acquiring the original data
	var bibs = {{session['bibs_0']|safe}};
	var cluster_desc = {{ cluster_desc|tojson|safe }};
	var query = {{query|tojson}};
	var hue = {{hue|safe}};
	var satr = {{satr|safe}};
	var val = {{val|safe}};
	var data_length = {{id2freq|length}};
	var edges = {{ edges|tojson|safe }};


    var dataset =  [];

    {% for id in id2freq %}

        {
        var keywords = [];
		for (const w of cluster_desc[{{id}}]) {
            keywords.push(w);
		}
        const current_data = { keywords: keywords, count: {{ id2freq[id] }}, id: "{{id}}" , members:{{id2members[id]|safe}}, cx: {{ xy[loop.index - 1][0]  }}, cy: {{ xy[loop.index - 1][1] }}, hue:{{hue[id]|safe}}, satr:{{satr[id]|safe}}, val:{{val[id]|safe}}, edges: edges, bibs: bibs};
        dataset.push(current_data);
        }

    {% endfor %}


		// Add log
	  console.log("Initial clustering being done");
	//   console.log("dataset: " + JSON.stringify(dataset));
	  // Print only the keys of the dataset
	//   console.log("dataset keys: " + Object.keys(dataset));
	  rerenderClusters(dataset, 0);


});

}

</script>



<div style='margin-top: 60px'>
	<div id="cluster" class="cluster" style="z-index: 0;">
		<div class="bubbleChart" id="tabs-cluster"></div>
	</div>
	<!-- <nav id="entities_menu" style="background-color: dodgerblue; opacity: 0.7; margin-left: 8px; padding: 10px; border-radius: 5px; position: fixed; z-index: 1;"> -->
	<!-- Make the entities_menu invisible -->
	{% if dataset != 'PubMedAPI' %}
	<style>
		#entities_menu {
			opacity: 0 !important;
		}
	</style>
	{% endif %}
	<nav id="entities_menu"
		style="background-color: #4c6d92; opacity: 0.7; margin-left: 8px; padding: 10px; border-radius: 5px; position: fixed; z-index: 1;">
		<!-- <div id="marker" style="width:47px"></div> -->
		{% if dataset == 'PubMedAPI' %}
		<a href="#" id='keywords' onClick="refreshEntity('keywords')">Keywords</a>
		<a href="#" id='authors' onClick="refreshEntity('authors')">Authors</a>
		{% elif dataset == 'Experts' %}
		<a href="#" id='experts' onClick="refreshEntity('experts')">Experts</a>
		<a href="#" id='topics' onClick="refreshEntity('topics')">Topics</a>
		{% elif dataset == 'DigiSquare' %}
		<a href="#" id='topics' onClick="refreshEntity('topics')">Topics</a>
		{% endif %}
	</nav>
	<form class="searchBar" name="Go" action="" method="POST" enctype="multipart/form-data" id="usrform">
		<!-- change input to value="{{ query }}" for non-voice -->
		<input type="text" name="query" id="query-secondary" value="{{ query }}" autofocus>
		<!--
		<input id='Explore' style='background:DodgerBlue;color:white;opacity:.70;height:9%; position:relative; z-index:99;' type=submit value="Search">
		-->

		<button id='Explore' class="searchButton btn btn-primary" type=submit value="Search"><i
				class="fas fa-search"></i></button>
		<!-- <div class = 'select'> -->
		<select style='text-align:center;color:white;background-color:white;opacity:0.0; display:none'
			name="dataset_opt" id='dataset_opt'>
			<option value="PubMedAPI"></option>
			<!-- <option value="GoogleAPI3">Basic Sciences</option>
			<option value="GoogleAPI">Computer & Information Sciences</option>
			<option value="GoogleAPI2">Government & Academia</option>
			<option value="NewsAPI">News</option> -->
		</select>
		<div class='select'>
			<select name="field" id='field' style="display: none">
				<option value="All fields" defaultOpen>All fields</option>
			</select>
			<!--<div class="select__arrow"></div>-->
		</div>


		<div class="buttons" style='visibility:hidden'>
			<p class="button" style="text-align:left;">
				<a class="btn" onclick='goHome()' id="home">Search Again</a>
				<a class="btn" href="#" id="back">Zoom Out</a>
				<a class="btn" href="#" id="calculate">Zoom In</a>
				<!--<a class="btn" href="#" id="bydate">ByDate</a>-->
			</p>
		</div>
	</form>

	<div id="loading">
		<h2 style="font-size: 25px;">ShowMe.news IS RETRIEVING YOUR RESULTS</h2>
		<div class="loader"></div>
	</div>
</div>


<div id="footer" style="position:fixed; bottom:15px; width:100%; display: flex; flex-direction: column; gap: 10px; ">
	<div style="margin: 0 auto; display: flex; gap: 10px; ">
		<button id="zoom-in-button" type="scatter-gather-button"
			style="display: none; width: 120px; margin: 0 auto; padding: 2px 10px 2px 10px; font-size: 1.2em; border: 0px; border-radius: 5px; background-color: #4c6d92; color:white;">Zoom
			In</button>
		<button id="zoom-out-button" type="scatter-gather-button"
			style="display: none; width: 120px; margin: 0 auto; padding: 2px 10px 2px 10px; font-size: 1.2em; border: 0px; border-radius: 5px; background-color: #4c6d92; color:white;">Zoom
			Out</button>
	</div>
	<div id="query-info" style="margin: 0 auto; text-align:center; padding: 10;">
		<button type="button" class="collapse-button arrow down"></button>
		<div id="math-tex" class="collapsible"
			style="font-size:75%; margin-top: 0; margin-bottom: 0; color: lightgray; ">
		</div>
	</div>
	<div style="position: absolute; right: 10px; bottom: 10px; color: #4c6d92; font-size: 10px;">
		&copy; 2024 LAIR
	</div>
</div>

<script type=text/javascript charset="utf-8">
	// configure collapse button to toggle math tex on click
    var coll = document.getElementsByClassName("collapse-button")[0];

    coll.addEventListener("click", function() {
      this.classList.toggle("active");
      var tex = this.nextElementSibling;
      if (tex.style.maxHeight) {
        tex.style.maxHeight = null;
      } else {
        tex.style.maxHeight = tex.scrollHeight + "px";
      }
	  // change arrow direction
      this.classList.toggle("down");
      this.classList.toggle("up");
    });

	// record user's selected cluster ids for each zoom in/out level
    var current_selection_trace = {
      ids_internal: [new Set()],
      level: 0,
      ids_listener: function(val) {},
      increaseLevel: function() {
        this.level += 1;
        this.ids_internal.push(new Set());
        this.ids_listener();
		return this.level;
      },
      decreaseLevel: function() {
        this.level -= 1;
        this.ids_internal.pop();
        this.cleanPreviousLevel();
		return this.level;
      },
      cleanPreviousLevel: function() {
        this.ids_internal[this.level].clear();
        this.ids_listener();
      },
      addId: function(val) {
        this.ids_internal[this.level].add(val);
        this.ids_listener();
      },
      removeId: function(val) {
        this.ids_internal[this.level].delete(val);
        this.ids_listener();
      },
      get ids() {
        return this.ids_internal;
      },
      get current_selected_bibs() {
        const sessionData = JSON.parse(sessionStorage.getItem('sessionData'));
        var selected_bibs = [];
        const id2members = sessionData[`id2members_${this.level}`];
        const current_cluster_ids = this.ids[this.level];
        for (const id of current_cluster_ids) {
            selected_bibs = selected_bibs.concat(id2members[id]) // add current cluster's bib ids to the current selected collection
        }
        const selected_bibs_set = new Set(selected_bibs);
		return selected_bibs_set;
      },
      registerListener: function(listener) {
        this.ids_listener = listener;
      }
    }

    var tex_node = document.getElementById('math-tex');

    function readjustTeXHeight() {
        var tex_node = document.getElementById('math-tex');
        if (tex_node.style.maxHeight) {
            tex_node.style.maxHeight = tex_node.scrollHeight + "px";
        }
    }
    function rerenderZoomInButton() {
        const sessionData = JSON.parse(sessionStorage.getItem('sessionData'));
        // handle zoom in button display and disappear
        var selected_bibs = [];
        const current_level = current_selection_trace.level;
        if (current_level >= 1) {
            document.getElementById('zoom-out-button').style.display = 'inline';
		} else {
            document.getElementById('zoom-out-button').style.display = 'none';
		}
        const id2members = sessionData[`id2members_${current_level}`];
        const current_cluster_ids = current_selection_trace.ids[current_level];
        for (const id of current_cluster_ids) {
            selected_bibs = selected_bibs.concat(id2members[id]) // add current cluster's bib ids to the current selected collection
        }
        const selected_bibs_set = new Set(selected_bibs);
        //console.log(selected_bibs_set);
        if (selected_bibs_set.size >= zoom_in_threshold) {
            document.getElementById('zoom-in-button').style.display = 'inline';
        } else {
            document.getElementById('zoom-in-button').style.display = 'none';
        }
    }

	function rerenderTeX() {
		// console.log("Rerendering TeX");
		const sessionData = JSON.parse(sessionStorage.getItem('sessionData'));
		var TeX = `\\text{Current query path: {{query|safe}}}`;
		// console.log("Current query path: " + TeX);
		// current_selection_trace.ids
		// console.log("Current selection trace: ", current_selection_trace.ids);
		// Print the state of the current selection trace
		// console.log("Current selection trace level: ", current_selection_trace.level);
		for (const level in current_selection_trace.ids) {
			// console.log("Level: " + level);
			// console.log("Cluster_desc: " + sessionData[`cluster_desc_${level}`]);
			// console.log("Cluster_summary: " + sessionData[`cluster_summary_${level}`]);
			// console.log("Cluster_ids: " + current_selection_trace.ids[level]);
			const cluster_desc = sessionData[`cluster_desc_${level}`];
			const cluster_summary = sessionData[`cluster_summary_${level}`];
			const cluster_ids = [...current_selection_trace.ids[level]];
			// cluster_ids is a object Set, so log it as an array
			
			// console.log("Cluster IDs: " + 
			// console.log("Cluster Description: " + cluster_desc[cluster_ids]);
			// console.log("Cluster Summary: " + cluster_summary[cluster_ids]);
			if (cluster_ids.length == 0) { break; }
			TeX += "\\to\\left\\{\\begin{array}{l}"; // single column for better readability
			if (level < current_selection_trace.level) {
				if (level == current_selection_trace.level - 1 && current_selection_trace.ids[current_selection_trace.level].size == 0) {
					for (const id of cluster_ids) {
						const keywords = cluster_desc[id];
						const summary = cluster_summary[id];
						// TeX += `\\text{\\textbf{Cluster ${id}}:  ${summary} (Keywords: ${keywords.slice(0, 5).join(', ')})} \\\\`; // keywords inside curly brackets
						TeX += `\\text{\\textbf{Cluster ${id}}:  ${summary}} \\\\`; // keywords inside curly brackets


					}
				} else {
					for (const id of cluster_ids) {
						const keywords = cluster_desc[id];
						const summary = cluster_summary[id];
						// TeX += `\\text{\\textbf{Cluster ${id}}:  ${summary} (Keywords: ${keywords.slice(0, 5).join(', ')})} \\\\`; // keywords inside curly brackets
						TeX += `\\text{\\textbf{Cluster ${id}}:  ${summary}} \\\\`; // keywords inside curly brackets
						if (keywords.length > 2) {
							TeX += "... \\\\";
						} else {
							TeX += " \\\\";
						}
					}
				}
			} else {
				for (const id of cluster_ids) {
					const keywords = cluster_desc[id];
					const summary = cluster_summary[id];
					// TeX += `\\text{\\textbf{Cluster ${id}}:  ${summary} (Keywords: ${keywords.slice(0, 5).join(', ')})} \\\\`; // keywords inside curly brackets
					TeX += `\\text{\\textbf{Cluster ${id}}:  ${summary}} \\\\`; // keywords inside curly brackets

				}
			}

			TeX += "\\end{array}\\right\\}"; 
		}

		// Print the final TeX to console
		// console.log("Final TeX: " + TeX);

		// Render the TeX with improved formatting options
		katex.render(TeX, tex_node, {
			throwOnError: false,
			displayMode: true, // Use display mode for better formatting
			macros: {
				"\\ClusterID": "\\textbf", // Define a macro for cluster IDs
				"\\KeywordList": "\\textit" // Define a macro for keyword lists
			}
		});
	}




    function modifyUIonSelectionChanges() {
        rerenderZoomInButton();
        rerenderTeX();
		readjustTeXHeight();
    }

    current_selection_trace.registerListener(modifyUIonSelectionChanges);

	document.addEventListener("DOMContentLoaded", function() { // wait for katex to finish loading so that we can actually rerender LaTeX
		const lastQuery = sessionStorage.getItem('currentDecoratedQuery');
		const currentQuery = {{decoratedQuery|tojson}};
    	var selection_trace = JSON.parse(sessionStorage.getItem('selection_trace'));
    	if (selection_trace) {
            if (currentQuery == lastQuery) {
                current_selection_trace.ids_internal = selection_trace.ids.map(x => new Set(x));
                current_selection_trace.level = selection_trace.level;
                rerenderTeX();
            }
            sessionStorage.removeItem('selection_trace');
    	}
	})


    window.addEventListener('beforeunload', function (e) { // before page refresh
        if (current_selection_trace.level > 0) {
            current_selection_trace.ids_internal.pop(); // pop current level's selection because when zoom in new set will be added again
            var selection_trace = {
                ids: current_selection_trace.ids.map(x => [...x]), // convert set to array to load into json
                level: current_selection_trace.level - 1 // downgrade one level because when zoom in it will be increased again
            }
            sessionStorage.setItem('selection_trace', JSON.stringify(selection_trace)); // store current_selection_trace before refreshing happens
		} else {
            var selection_trace = {
                ids: [[]],
                level: 0
            }
            sessionStorage.setItem('selection_trace', JSON.stringify(selection_trace)); // store current_selection_trace before refreshing happens
		}
        // the absence of a returnValue property on the event will guarantee the browser unload happens
        delete e['returnValue'];
    });


</script>



{% endblock %}